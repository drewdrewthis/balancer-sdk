# [allow (dead_code)] pub mod liquidity_bootstrapping_pool { # [rustfmt :: skip] use ethcontract as ethcontract ; # [doc = "Generated by `ethcontract`"] # [derive (Clone)] pub struct Contract { methods : Methods , } impl Contract { # [doc = r" Retrieves the raw contract instance used to generate the type safe"] # [doc = r" API for this contract."] pub fn raw_contract () -> & 'static self :: ethcontract :: Contract { use self :: ethcontract :: common :: artifact :: truffle :: TruffleLoader ; use self :: ethcontract :: private :: lazy_static ; use self :: ethcontract :: Contract ; lazy_static ! { pub static ref CONTRACT : Contract = { # [allow (unused_mut)] let mut contract = TruffleLoader :: new () . load_contract_from_str ("{\"contractName\":\"LiquidityBootstrappingPool\",\"abi\":[{\"type\":\"constructor\",\"inputs\":[{\"internalType\":\"contract IVault\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"normalizedWeights\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"swapFeePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pauseWindowDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferPeriodDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"swapEnabledOnStart\",\"type\":\"bool\"}]},{\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"decreaseAllowance\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"getActionId\",\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getAuthorizer\",\"inputs\":[],\"outputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"\",\"type\":\"address\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getGradualWeightUpdateParams\",\"inputs\":[],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"endWeights\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getInvariant\",\"inputs\":[],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getLastInvariant\",\"inputs\":[],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getNormalizedWeights\",\"inputs\":[],\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getOwner\",\"inputs\":[],\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getPausedState\",\"inputs\":[],\"outputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pauseWindowEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferPeriodEndTime\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getPoolId\",\"inputs\":[],\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getRate\",\"inputs\":[],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getSwapEnabled\",\"inputs\":[],\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getSwapFeePercentage\",\"inputs\":[],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getVault\",\"inputs\":[],\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"increaseAllowance\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"nonces\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"onExitPool\",\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastChangeBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolSwapFeePercentage\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"onJoinPool\",\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastChangeBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolSwapFeePercentage\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"onSwap\",\"inputs\":[{\"internalType\":\"struct IPoolSwapStructs.SwapRequest\",\"name\":\"request\",\"type\":\"tuple\",\"components\":[{\"type\":\"uint8\"},{\"type\":\"address\"},{\"type\":\"address\"},{\"type\":\"uint256\"},{\"type\":\"bytes32\"},{\"type\":\"uint256\"},{\"type\":\"address\"},{\"type\":\"address\"},{\"type\":\"bytes\"}]},{\"internalType\":\"uint256\",\"name\":\"balanceTokenIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceTokenOut\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"permit\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"queryExit\",\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastChangeBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolSwapFeePercentage\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bptIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"queryJoin\",\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastChangeBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolSwapFeePercentage\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bptOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsIn\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setAssetManagerPoolConfig\",\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"poolConfig\",\"type\":\"bytes\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setPaused\",\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setSwapEnabled\",\"inputs\":[{\"internalType\":\"bool\",\"name\":\"swapEnabled\",\"type\":\"bool\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setSwapFeePercentage\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFeePercentage\",\"type\":\"uint256\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"updateWeightsGradually\",\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"endWeights\",\"type\":\"uint256[]\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"event\",\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"GradualWeightUpdateScheduled\",\"inputs\":[{\"name\":\"startTime\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"endTime\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"startWeights\",\"type\":\"uint256[]\",\"indexed\":false},{\"name\":\"endWeights\",\"type\":\"uint256[]\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"PausedStateChanged\",\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"SwapEnabledSet\",\"inputs\":[{\"name\":\"swapEnabled\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"SwapFeePercentageChanged\",\"inputs\":[{\"name\":\"swapFeePercentage\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Transfer\",\"inputs\":[{\"name\":\"from\",\"type\":\"address\",\"indexed\":true},{\"name\":\"to\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false}],\"bytecode\":\"\",\"networks\":{},\"devdoc\":{\"details\":null,\"methods\":{}},\"userdoc\":{\"details\":null,\"methods\":{}}}") . expect ("valid contract JSON") ; contract } ; } & CONTRACT } # [doc = r" Creates a new contract instance with the specified `web3`"] # [doc = r" provider at the given `Address`."] # [doc = r""] # [doc = r" Note that this does not verify that a contract with a matching"] # [doc = r" `Abi` is actually deployed at the given address."] pub fn at < F , B , T > (web3 : & self :: ethcontract :: web3 :: api :: Web3 < T > , address : self :: ethcontract :: Address ,) -> Self where F : std :: future :: Future < Output = Result < self :: ethcontract :: json :: Value , self :: ethcontract :: web3 :: Error , > , > + Send + 'static , B : std :: future :: Future < Output = Result < Vec < Result < self :: ethcontract :: json :: Value , self :: ethcontract :: web3 :: Error , > , > , self :: ethcontract :: web3 :: Error , > , > + Send + 'static , T : self :: ethcontract :: web3 :: Transport < Out = F > + self :: ethcontract :: web3 :: BatchTransport < Batch = B > + Send + Sync + 'static , { Contract :: with_deployment_info (web3 , address , None) } # [doc = r" Creates a new contract instance with the specified `web3` provider with"] # [doc = r" the given `Abi` at the given `Address` and an optional transaction hash."] # [doc = r" This hash is used to retrieve contract related information such as the"] # [doc = r" creation block (which is useful for fetching all historic events)."] # [doc = r""] # [doc = r" Note that this does not verify that a contract with a matching `Abi` is"] # [doc = r" actually deployed at the given address nor that the transaction hash,"] # [doc = r" when provided, is actually for this contract deployment."] pub fn with_deployment_info < F , B , T > (web3 : & self :: ethcontract :: web3 :: api :: Web3 < T > , address : self :: ethcontract :: Address , deployment_information : Option < ethcontract :: common :: DeploymentInformation > ,) -> Self where F : std :: future :: Future < Output = Result < self :: ethcontract :: json :: Value , self :: ethcontract :: web3 :: Error , > , > + Send + 'static , B : std :: future :: Future < Output = Result < Vec < Result < self :: ethcontract :: json :: Value , self :: ethcontract :: web3 :: Error , > , > , self :: ethcontract :: web3 :: Error , > , > + Send + 'static , T : self :: ethcontract :: web3 :: Transport < Out = F > + self :: ethcontract :: web3 :: BatchTransport < Batch = B > + Send + Sync + 'static , { use self :: ethcontract :: Instance ; use self :: ethcontract :: transport :: DynTransport ; use self :: ethcontract :: web3 :: api :: Web3 ; let transport = DynTransport :: new (web3 . transport () . clone ()) ; let web3 = Web3 :: new (transport) ; let abi = Self :: raw_contract () . abi . clone () ; let instance = Instance :: with_deployment_info (web3 , abi , address , deployment_information) ; Contract :: from_raw (instance) } # [doc = r" Creates a contract from a raw instance."] fn from_raw (instance : self :: ethcontract :: dyns :: DynInstance) -> Self { let methods = Methods { instance } ; Contract { methods } } # [doc = r" Returns the contract address being used by this instance."] pub fn address (& self) -> self :: ethcontract :: Address { self . raw_instance () . address () } # [doc = r" Returns the deployment information of the contract"] # [doc = r" if it is known, `None` otherwise."] pub fn deployment_information (& self) -> Option < ethcontract :: common :: DeploymentInformation > { self . raw_instance () . deployment_information () } # [doc = r" Returns a reference to the default method options used by this"] # [doc = r" contract."] pub fn defaults (& self) -> & self :: ethcontract :: contract :: MethodDefaults { & self . raw_instance () . defaults } # [doc = r" Returns a mutable reference to the default method options used"] # [doc = r" by this contract."] pub fn defaults_mut (& mut self) -> & mut self :: ethcontract :: contract :: MethodDefaults { & mut self . raw_instance_mut () . defaults } # [doc = r" Returns a reference to the raw runtime instance used by this"] # [doc = r" contract."] pub fn raw_instance (& self) -> & self :: ethcontract :: dyns :: DynInstance { & self . methods . instance } # [doc = r" Returns a mutable reference to the raw runtime instance used by"] # [doc = r" this contract."] fn raw_instance_mut (& mut self) -> & mut self :: ethcontract :: dyns :: DynInstance { & mut self . methods . instance } } impl std :: fmt :: Debug for Contract { fn fmt (& self , f : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { f . debug_tuple (stringify ! (LiquidityBootstrappingPool)) . field (& self . address ()) . finish () } } impl Contract { # [doc = r" Returns an object that allows accessing typed method signatures."] pub fn signatures () -> Signatures { Signatures } # [doc = r" Retrieves a reference to type containing all the generated"] # [doc = r" contract methods. This can be used for methods where the name"] # [doc = r" would collide with a common method (like `at` or `deployed`)."] pub fn methods (& self) -> & Methods { & self . methods } } # [doc = r" Type containing signatures for all methods for generated contract type."] # [derive (Clone , Copy)] pub struct Signatures ; impl Signatures { # [doc = "Returns signature for method `DOMAIN_SEPARATOR():(bytes32)`."] # [allow (clippy :: type_complexity)] pub fn domain_separator (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > > { self :: ethcontract :: contract :: Signature :: new ([54 , 68 , 229 , 21]) } # [doc = "Returns signature for method `allowance(address,address):(uint256)`."] # [allow (clippy :: type_complexity)] pub fn allowance (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address , self :: ethcontract :: Address ,) , self :: ethcontract :: U256 > { self :: ethcontract :: contract :: Signature :: new ([221 , 98 , 237 , 62]) } # [doc = "Returns signature for method `approve(address,uint256):(bool)`."] # [allow (clippy :: type_complexity)] pub fn approve (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address , self :: ethcontract :: U256 ,) , bool > { self :: ethcontract :: contract :: Signature :: new ([9 , 94 , 167 , 179]) } # [doc = "Returns signature for method `balanceOf(address):(uint256)`."] # [allow (clippy :: type_complexity)] pub fn balance_of (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address ,) , self :: ethcontract :: U256 > { self :: ethcontract :: contract :: Signature :: new ([112 , 160 , 130 , 49]) } # [doc = "Returns signature for method `decimals():(uint8)`."] # [allow (clippy :: type_complexity)] pub fn decimals (& self) -> self :: ethcontract :: contract :: Signature < () , u8 > { self :: ethcontract :: contract :: Signature :: new ([49 , 60 , 229 , 103]) } # [doc = "Returns signature for method `decreaseAllowance(address,uint256):(bool)`."] # [allow (clippy :: type_complexity)] pub fn decrease_allowance (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address , self :: ethcontract :: U256 ,) , bool > { self :: ethcontract :: contract :: Signature :: new ([164 , 87 , 194 , 215]) } # [doc = "Returns signature for method `getActionId(bytes4):(bytes32)`."] # [allow (clippy :: type_complexity)] pub fn get_action_id (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 4] > ,) , self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > > { self :: ethcontract :: contract :: Signature :: new ([133 , 28 , 27 , 179]) } # [doc = "Returns signature for method `getAuthorizer():(address)`."] # [allow (clippy :: type_complexity)] pub fn get_authorizer (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: Address > { self :: ethcontract :: contract :: Signature :: new ([170 , 171 , 173 , 197]) } # [doc = "Returns signature for method `getGradualWeightUpdateParams():(uint256,uint256,uint256[])`."] # [allow (clippy :: type_complexity)] pub fn get_gradual_weight_update_params (& self) -> self :: ethcontract :: contract :: Signature < () , (self :: ethcontract :: U256 , self :: ethcontract :: U256 , Vec < self :: ethcontract :: U256 >) > { self :: ethcontract :: contract :: Signature :: new ([123 , 238 , 210 , 32]) } # [doc = "Returns signature for method `getInvariant():(uint256)`."] # [allow (clippy :: type_complexity)] pub fn get_invariant (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: U256 > { self :: ethcontract :: contract :: Signature :: new ([192 , 255 , 26 , 21]) } # [doc = "Returns signature for method `getLastInvariant():(uint256)`."] # [allow (clippy :: type_complexity)] pub fn get_last_invariant (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: U256 > { self :: ethcontract :: contract :: Signature :: new ([155 , 2 , 205 , 222]) } # [doc = "Returns signature for method `getNormalizedWeights():(uint256[])`."] # [allow (clippy :: type_complexity)] pub fn get_normalized_weights (& self) -> self :: ethcontract :: contract :: Signature < () , Vec < self :: ethcontract :: U256 > > { self :: ethcontract :: contract :: Signature :: new ([248 , 159 , 39 , 237]) } # [doc = "Returns signature for method `getOwner():(address)`."] # [allow (clippy :: type_complexity)] pub fn get_owner (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: Address > { self :: ethcontract :: contract :: Signature :: new ([137 , 61 , 32 , 232]) } # [doc = "Returns signature for method `getPausedState():(bool,uint256,uint256)`."] # [allow (clippy :: type_complexity)] pub fn get_paused_state (& self) -> self :: ethcontract :: contract :: Signature < () , (bool , self :: ethcontract :: U256 , self :: ethcontract :: U256) > { self :: ethcontract :: contract :: Signature :: new ([28 , 13 , 224 , 81]) } # [doc = "Returns signature for method `getPoolId():(bytes32)`."] # [allow (clippy :: type_complexity)] pub fn get_pool_id (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > > { self :: ethcontract :: contract :: Signature :: new ([56 , 255 , 242 , 208]) } # [doc = "Returns signature for method `getRate():(uint256)`."] # [allow (clippy :: type_complexity)] pub fn get_rate (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: U256 > { self :: ethcontract :: contract :: Signature :: new ([103 , 154 , 239 , 206]) } # [doc = "Returns signature for method `getSwapEnabled():(bool)`."] # [allow (clippy :: type_complexity)] pub fn get_swap_enabled (& self) -> self :: ethcontract :: contract :: Signature < () , bool > { self :: ethcontract :: contract :: Signature :: new ([71 , 188 , 77 , 146]) } # [doc = "Returns signature for method `getSwapFeePercentage():(uint256)`."] # [allow (clippy :: type_complexity)] pub fn get_swap_fee_percentage (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: U256 > { self :: ethcontract :: contract :: Signature :: new ([85 , 198 , 118 , 40]) } # [doc = "Returns signature for method `getVault():(address)`."] # [allow (clippy :: type_complexity)] pub fn get_vault (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: Address > { self :: ethcontract :: contract :: Signature :: new ([141 , 146 , 138 , 248]) } # [doc = "Returns signature for method `increaseAllowance(address,uint256):(bool)`."] # [allow (clippy :: type_complexity)] pub fn increase_allowance (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address , self :: ethcontract :: U256 ,) , bool > { self :: ethcontract :: contract :: Signature :: new ([57 , 80 , 147 , 81]) } # [doc = "Returns signature for method `name():(string)`."] # [allow (clippy :: type_complexity)] pub fn name (& self) -> self :: ethcontract :: contract :: Signature < () , String > { self :: ethcontract :: contract :: Signature :: new ([6 , 253 , 222 , 3]) } # [doc = "Returns signature for method `nonces(address):(uint256)`."] # [allow (clippy :: type_complexity)] pub fn nonces (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address ,) , self :: ethcontract :: U256 > { self :: ethcontract :: contract :: Signature :: new ([126 , 206 , 190 , 0]) } # [doc = "Returns signature for method `onExitPool(bytes32,address,address,uint256[],uint256,uint256,bytes):(uint256[],uint256[])`."] # [allow (clippy :: type_complexity)] pub fn on_exit_pool (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: Address , self :: ethcontract :: Address , Vec < self :: ethcontract :: U256 > , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) , (Vec < self :: ethcontract :: U256 > , Vec < self :: ethcontract :: U256 >) > { self :: ethcontract :: contract :: Signature :: new ([116 , 243 , 176 , 9]) } # [doc = "Returns signature for method `onJoinPool(bytes32,address,address,uint256[],uint256,uint256,bytes):(uint256[],uint256[])`."] # [allow (clippy :: type_complexity)] pub fn on_join_pool (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: Address , self :: ethcontract :: Address , Vec < self :: ethcontract :: U256 > , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) , (Vec < self :: ethcontract :: U256 > , Vec < self :: ethcontract :: U256 >) > { self :: ethcontract :: contract :: Signature :: new ([213 , 192 , 150 , 196]) } # [doc = "Returns signature for method `onSwap((uint8,address,address,uint256,bytes32,uint256,address,address,bytes),uint256,uint256):(uint256)`."] # [allow (clippy :: type_complexity)] pub fn on_swap (& self) -> self :: ethcontract :: contract :: Signature < ((u8 , self :: ethcontract :: Address , self :: ethcontract :: Address , self :: ethcontract :: U256 , self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: U256 , self :: ethcontract :: Address , self :: ethcontract :: Address , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) , self :: ethcontract :: U256 , self :: ethcontract :: U256 ,) , self :: ethcontract :: U256 > { self :: ethcontract :: contract :: Signature :: new ([157 , 44 , 17 , 12]) } # [doc = "Returns signature for method `permit(address,address,uint256,uint256,uint8,bytes32,bytes32)`."] # [allow (clippy :: type_complexity)] pub fn permit (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address , self :: ethcontract :: Address , self :: ethcontract :: U256 , self :: ethcontract :: U256 , u8 , self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > ,) , () > { self :: ethcontract :: contract :: Signature :: new ([213 , 5 , 172 , 207]) } # [doc = "Returns signature for method `queryExit(bytes32,address,address,uint256[],uint256,uint256,bytes):(uint256,uint256[])`."] # [allow (clippy :: type_complexity)] pub fn query_exit (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: Address , self :: ethcontract :: Address , Vec < self :: ethcontract :: U256 > , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) , (self :: ethcontract :: U256 , Vec < self :: ethcontract :: U256 >) > { self :: ethcontract :: contract :: Signature :: new ([96 , 40 , 191 , 212]) } # [doc = "Returns signature for method `queryJoin(bytes32,address,address,uint256[],uint256,uint256,bytes):(uint256,uint256[])`."] # [allow (clippy :: type_complexity)] pub fn query_join (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: Address , self :: ethcontract :: Address , Vec < self :: ethcontract :: U256 > , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) , (self :: ethcontract :: U256 , Vec < self :: ethcontract :: U256 >) > { self :: ethcontract :: contract :: Signature :: new ([135 , 236 , 104 , 23]) } # [doc = "Returns signature for method `setAssetManagerPoolConfig(address,bytes)`."] # [allow (clippy :: type_complexity)] pub fn set_asset_manager_pool_config (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) , () > { self :: ethcontract :: contract :: Signature :: new ([80 , 221 , 110 , 217]) } # [doc = "Returns signature for method `setPaused(bool)`."] # [allow (clippy :: type_complexity)] pub fn set_paused (& self) -> self :: ethcontract :: contract :: Signature < (bool ,) , () > { self :: ethcontract :: contract :: Signature :: new ([22 , 195 , 139 , 60]) } # [doc = "Returns signature for method `setSwapEnabled(bool)`."] # [allow (clippy :: type_complexity)] pub fn set_swap_enabled (& self) -> self :: ethcontract :: contract :: Signature < (bool ,) , () > { self :: ethcontract :: contract :: Signature :: new ([224 , 26 , 249 , 44]) } # [doc = "Returns signature for method `setSwapFeePercentage(uint256)`."] # [allow (clippy :: type_complexity)] pub fn set_swap_fee_percentage (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: U256 ,) , () > { self :: ethcontract :: contract :: Signature :: new ([56 , 233 , 146 , 46]) } # [doc = "Returns signature for method `symbol():(string)`."] # [allow (clippy :: type_complexity)] pub fn symbol (& self) -> self :: ethcontract :: contract :: Signature < () , String > { self :: ethcontract :: contract :: Signature :: new ([149 , 216 , 155 , 65]) } # [doc = "Returns signature for method `totalSupply():(uint256)`."] # [allow (clippy :: type_complexity)] pub fn total_supply (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: U256 > { self :: ethcontract :: contract :: Signature :: new ([24 , 22 , 13 , 221]) } # [doc = "Returns signature for method `transfer(address,uint256):(bool)`."] # [allow (clippy :: type_complexity)] pub fn transfer (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address , self :: ethcontract :: U256 ,) , bool > { self :: ethcontract :: contract :: Signature :: new ([169 , 5 , 156 , 187]) } # [doc = "Returns signature for method `transferFrom(address,address,uint256):(bool)`."] # [allow (clippy :: type_complexity)] pub fn transfer_from (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address , self :: ethcontract :: Address , self :: ethcontract :: U256 ,) , bool > { self :: ethcontract :: contract :: Signature :: new ([35 , 184 , 114 , 221]) } # [doc = "Returns signature for method `updateWeightsGradually(uint256,uint256,uint256[])`."] # [allow (clippy :: type_complexity)] pub fn update_weights_gradually (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: U256 , self :: ethcontract :: U256 , Vec < self :: ethcontract :: U256 > ,) , () > { self :: ethcontract :: contract :: Signature :: new ([62 , 86 , 146 , 5]) } } # [doc = r" Type containing all contract methods for generated contract type."] # [derive (Clone)] pub struct Methods { instance : self :: ethcontract :: dyns :: DynInstance , } # [allow (clippy :: too_many_arguments , clippy :: type_complexity)] impl Methods { # [doc = "Generated by `ethcontract`"] pub fn domain_separator (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > > { self . instance . view_method ([54 , 68 , 229 , 21] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn allowance (& self , owner : self :: ethcontract :: Address , spender : self :: ethcontract :: Address) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: U256 > { self . instance . view_method ([221 , 98 , 237 , 62] , (owner , spender ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn approve (& self , spender : self :: ethcontract :: Address , amount : self :: ethcontract :: U256) -> self :: ethcontract :: dyns :: DynMethodBuilder < bool > { self . instance . method ([9 , 94 , 167 , 179] , (spender , amount ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn balance_of (& self , account : self :: ethcontract :: Address) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: U256 > { self . instance . view_method ([112 , 160 , 130 , 49] , (account ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn decimals (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < u8 > { self . instance . view_method ([49 , 60 , 229 , 103] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn decrease_allowance (& self , spender : self :: ethcontract :: Address , amount : self :: ethcontract :: U256) -> self :: ethcontract :: dyns :: DynMethodBuilder < bool > { self . instance . method ([164 , 87 , 194 , 215] , (spender , amount ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_action_id (& self , selector : self :: ethcontract :: tokens :: Bytes < [u8 ; 4] >) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > > { self . instance . view_method ([133 , 28 , 27 , 179] , (selector ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_authorizer (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: Address > { self . instance . view_method ([170 , 171 , 173 , 197] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_gradual_weight_update_params (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < (self :: ethcontract :: U256 , self :: ethcontract :: U256 , Vec < self :: ethcontract :: U256 >) > { self . instance . view_method ([123 , 238 , 210 , 32] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_invariant (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: U256 > { self . instance . view_method ([192 , 255 , 26 , 21] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_last_invariant (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: U256 > { self . instance . view_method ([155 , 2 , 205 , 222] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_normalized_weights (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < Vec < self :: ethcontract :: U256 > > { self . instance . view_method ([248 , 159 , 39 , 237] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_owner (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: Address > { self . instance . view_method ([137 , 61 , 32 , 232] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_paused_state (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < (bool , self :: ethcontract :: U256 , self :: ethcontract :: U256) > { self . instance . view_method ([28 , 13 , 224 , 81] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_pool_id (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > > { self . instance . view_method ([56 , 255 , 242 , 208] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_rate (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: U256 > { self . instance . view_method ([103 , 154 , 239 , 206] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_swap_enabled (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < bool > { self . instance . view_method ([71 , 188 , 77 , 146] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_swap_fee_percentage (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: U256 > { self . instance . view_method ([85 , 198 , 118 , 40] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_vault (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: Address > { self . instance . view_method ([141 , 146 , 138 , 248] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn increase_allowance (& self , spender : self :: ethcontract :: Address , added_value : self :: ethcontract :: U256) -> self :: ethcontract :: dyns :: DynMethodBuilder < bool > { self . instance . method ([57 , 80 , 147 , 81] , (spender , added_value ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn name (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < String > { self . instance . view_method ([6 , 253 , 222 , 3] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn nonces (& self , owner : self :: ethcontract :: Address) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: U256 > { self . instance . view_method ([126 , 206 , 190 , 0] , (owner ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn on_exit_pool (& self , pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , sender : self :: ethcontract :: Address , recipient : self :: ethcontract :: Address , balances : Vec < self :: ethcontract :: U256 > , last_change_block : self :: ethcontract :: U256 , protocol_swap_fee_percentage : self :: ethcontract :: U256 , user_data : self :: ethcontract :: tokens :: Bytes < Vec < u8 >>) -> self :: ethcontract :: dyns :: DynMethodBuilder < (Vec < self :: ethcontract :: U256 > , Vec < self :: ethcontract :: U256 >) > { self . instance . method ([116 , 243 , 176 , 9] , (pool_id , sender , recipient , balances , last_change_block , protocol_swap_fee_percentage , user_data ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn on_join_pool (& self , pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , sender : self :: ethcontract :: Address , recipient : self :: ethcontract :: Address , balances : Vec < self :: ethcontract :: U256 > , last_change_block : self :: ethcontract :: U256 , protocol_swap_fee_percentage : self :: ethcontract :: U256 , user_data : self :: ethcontract :: tokens :: Bytes < Vec < u8 >>) -> self :: ethcontract :: dyns :: DynMethodBuilder < (Vec < self :: ethcontract :: U256 > , Vec < self :: ethcontract :: U256 >) > { self . instance . method ([213 , 192 , 150 , 196] , (pool_id , sender , recipient , balances , last_change_block , protocol_swap_fee_percentage , user_data ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn on_swap (& self , request : (u8 , self :: ethcontract :: Address , self :: ethcontract :: Address , self :: ethcontract :: U256 , self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: U256 , self :: ethcontract :: Address , self :: ethcontract :: Address , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) , balance_token_in : self :: ethcontract :: U256 , balance_token_out : self :: ethcontract :: U256) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: U256 > { self . instance . view_method ([157 , 44 , 17 , 12] , (request , balance_token_in , balance_token_out ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn permit (& self , owner : self :: ethcontract :: Address , spender : self :: ethcontract :: Address , value : self :: ethcontract :: U256 , deadline : self :: ethcontract :: U256 , v : u8 , r : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , s : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] >) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([213 , 5 , 172 , 207] , (owner , spender , value , deadline , v , r , s ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn query_exit (& self , pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , sender : self :: ethcontract :: Address , recipient : self :: ethcontract :: Address , balances : Vec < self :: ethcontract :: U256 > , last_change_block : self :: ethcontract :: U256 , protocol_swap_fee_percentage : self :: ethcontract :: U256 , user_data : self :: ethcontract :: tokens :: Bytes < Vec < u8 >>) -> self :: ethcontract :: dyns :: DynMethodBuilder < (self :: ethcontract :: U256 , Vec < self :: ethcontract :: U256 >) > { self . instance . method ([96 , 40 , 191 , 212] , (pool_id , sender , recipient , balances , last_change_block , protocol_swap_fee_percentage , user_data ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn query_join (& self , pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , sender : self :: ethcontract :: Address , recipient : self :: ethcontract :: Address , balances : Vec < self :: ethcontract :: U256 > , last_change_block : self :: ethcontract :: U256 , protocol_swap_fee_percentage : self :: ethcontract :: U256 , user_data : self :: ethcontract :: tokens :: Bytes < Vec < u8 >>) -> self :: ethcontract :: dyns :: DynMethodBuilder < (self :: ethcontract :: U256 , Vec < self :: ethcontract :: U256 >) > { self . instance . method ([135 , 236 , 104 , 23] , (pool_id , sender , recipient , balances , last_change_block , protocol_swap_fee_percentage , user_data ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn set_asset_manager_pool_config (& self , token : self :: ethcontract :: Address , pool_config : self :: ethcontract :: tokens :: Bytes < Vec < u8 >>) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([80 , 221 , 110 , 217] , (token , pool_config ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn set_paused (& self , paused : bool) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([22 , 195 , 139 , 60] , (paused ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn set_swap_enabled (& self , swap_enabled : bool) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([224 , 26 , 249 , 44] , (swap_enabled ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn set_swap_fee_percentage (& self , swap_fee_percentage : self :: ethcontract :: U256) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([56 , 233 , 146 , 46] , (swap_fee_percentage ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn symbol (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < String > { self . instance . view_method ([149 , 216 , 155 , 65] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn total_supply (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: U256 > { self . instance . view_method ([24 , 22 , 13 , 221] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn transfer (& self , recipient : self :: ethcontract :: Address , amount : self :: ethcontract :: U256) -> self :: ethcontract :: dyns :: DynMethodBuilder < bool > { self . instance . method ([169 , 5 , 156 , 187] , (recipient , amount ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn transfer_from (& self , sender : self :: ethcontract :: Address , recipient : self :: ethcontract :: Address , amount : self :: ethcontract :: U256) -> self :: ethcontract :: dyns :: DynMethodBuilder < bool > { self . instance . method ([35 , 184 , 114 , 221] , (sender , recipient , amount ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn update_weights_gradually (& self , start_time : self :: ethcontract :: U256 , end_time : self :: ethcontract :: U256 , end_weights : Vec < self :: ethcontract :: U256 >) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([62 , 86 , 146 , 5] , (start_time , end_time , end_weights ,)) . expect ("generated call") } } impl std :: ops :: Deref for Contract { type Target = Methods ; fn deref (& self) -> & Self :: Target { & self . methods } } # [doc = r" Module containing all generated data models for this contract's"] # [doc = r" events."] pub mod event_data { use super :: ethcontract ; # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct Approval { pub owner : self :: ethcontract :: Address , pub spender : self :: ethcontract :: Address , pub value : self :: ethcontract :: U256 , } impl Approval { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([140 , 91 , 225 , 229 , 235 , 236 , 125 , 91 , 209 , 79 , 113 , 66 , 125 , 30 , 132 , 243 , 221 , 3 , 20 , 192 , 247 , 178 , 41 , 30 , 91 , 32 , 10 , 200 , 199 , 195 , 185 , 37]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`Approval(address,address,uint256)`"] pub fn abi_signature () -> & 'static str { "Approval(address,address,uint256)" } } impl self :: ethcontract :: tokens :: Tokenize for Approval { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (owner , spender , value ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (Approval { owner , spender , value }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct GradualWeightUpdateScheduled { pub start_time : self :: ethcontract :: U256 , pub end_time : self :: ethcontract :: U256 , pub start_weights : Vec < self :: ethcontract :: U256 > , pub end_weights : Vec < self :: ethcontract :: U256 > , } impl GradualWeightUpdateScheduled { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([15 , 54 , 49 , 249 , 218 , 176 , 129 , 105 , 209 , 219 , 33 , 198 , 220 , 95 , 50 , 83 , 111 , 178 , 176 , 166 , 185 , 187 , 83 , 48 , 215 , 28 , 82 , 19 , 47 , 150 , 139 , 224]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`GradualWeightUpdateScheduled(uint256,uint256,uint256[],uint256[])`"] pub fn abi_signature () -> & 'static str { "GradualWeightUpdateScheduled(uint256,uint256,uint256[],uint256[])" } } impl self :: ethcontract :: tokens :: Tokenize for GradualWeightUpdateScheduled { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (start_time , end_time , start_weights , end_weights ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (GradualWeightUpdateScheduled { start_time , end_time , start_weights , end_weights }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct PausedStateChanged { pub paused : bool , } impl PausedStateChanged { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([158 , 58 , 94 , 55 , 34 , 69 , 50 , 222 , 166 , 123 , 137 , 250 , 206 , 24 , 87 , 3 , 115 , 138 , 34 , 138 , 110 , 138 , 35 , 222 , 229 , 70 , 150 , 1 , 128 , 211 , 190 , 100]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`PausedStateChanged(bool)`"] pub fn abi_signature () -> & 'static str { "PausedStateChanged(bool)" } } impl self :: ethcontract :: tokens :: Tokenize for PausedStateChanged { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (paused ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (PausedStateChanged { paused }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct SwapEnabledSet { pub swap_enabled : bool , } impl SwapEnabledSet { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([90 , 158 , 132 , 247 , 143 , 121 , 87 , 203 , 78 , 215 , 71 , 142 , 176 , 252 , 173 , 53 , 238 , 78 , 203 , 226 , 224 , 242 , 152 , 66 , 11 , 40 , 163 , 149 , 83 , 146 , 87 , 63]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`SwapEnabledSet(bool)`"] pub fn abi_signature () -> & 'static str { "SwapEnabledSet(bool)" } } impl self :: ethcontract :: tokens :: Tokenize for SwapEnabledSet { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (swap_enabled ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (SwapEnabledSet { swap_enabled }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct SwapFeePercentageChanged { pub swap_fee_percentage : self :: ethcontract :: U256 , } impl SwapFeePercentageChanged { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([169 , 186 , 63 , 254 , 11 , 108 , 54 , 107 , 129 , 35 , 44 , 170 , 179 , 134 , 5 , 160 , 105 , 154 , 213 , 57 , 141 , 108 , 206 , 118 , 249 , 30 , 232 , 9 , 227 , 34 , 218 , 252]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`SwapFeePercentageChanged(uint256)`"] pub fn abi_signature () -> & 'static str { "SwapFeePercentageChanged(uint256)" } } impl self :: ethcontract :: tokens :: Tokenize for SwapFeePercentageChanged { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (swap_fee_percentage ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (SwapFeePercentageChanged { swap_fee_percentage }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct Transfer { pub from : self :: ethcontract :: Address , pub to : self :: ethcontract :: Address , pub value : self :: ethcontract :: U256 , } impl Transfer { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([221 , 242 , 82 , 173 , 27 , 226 , 200 , 155 , 105 , 194 , 176 , 104 , 252 , 55 , 141 , 170 , 149 , 43 , 167 , 241 , 99 , 196 , 161 , 22 , 40 , 245 , 90 , 77 , 245 , 35 , 179 , 239]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`Transfer(address,address,uint256)`"] pub fn abi_signature () -> & 'static str { "Transfer(address,address,uint256)" } } impl self :: ethcontract :: tokens :: Tokenize for Transfer { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (from , to , value ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (Transfer { from , to , value }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } } impl Contract { # [doc = r" Retrieves a handle to a type containing for creating event"] # [doc = r" streams for all the contract events."] pub fn events (& self) -> Events < '_ > { Events { instance : self . raw_instance () , } } } pub struct Events < 'a > { instance : & 'a self :: ethcontract :: dyns :: DynInstance , } impl Events < '_ > { # [doc = r" Generated by `ethcontract`."] pub fn approval (& self) -> self :: event_builders :: ApprovalBuilder { self :: event_builders :: ApprovalBuilder (self . instance . event (self :: ethcontract :: H256 ([140 , 91 , 225 , 229 , 235 , 236 , 125 , 91 , 209 , 79 , 113 , 66 , 125 , 30 , 132 , 243 , 221 , 3 , 20 , 192 , 247 , 178 , 41 , 30 , 91 , 32 , 10 , 200 , 199 , 195 , 185 , 37])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn gradual_weight_update_scheduled (& self) -> self :: event_builders :: GradualWeightUpdateScheduledBuilder { self :: event_builders :: GradualWeightUpdateScheduledBuilder (self . instance . event (self :: ethcontract :: H256 ([15 , 54 , 49 , 249 , 218 , 176 , 129 , 105 , 209 , 219 , 33 , 198 , 220 , 95 , 50 , 83 , 111 , 178 , 176 , 166 , 185 , 187 , 83 , 48 , 215 , 28 , 82 , 19 , 47 , 150 , 139 , 224])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn paused_state_changed (& self) -> self :: event_builders :: PausedStateChangedBuilder { self :: event_builders :: PausedStateChangedBuilder (self . instance . event (self :: ethcontract :: H256 ([158 , 58 , 94 , 55 , 34 , 69 , 50 , 222 , 166 , 123 , 137 , 250 , 206 , 24 , 87 , 3 , 115 , 138 , 34 , 138 , 110 , 138 , 35 , 222 , 229 , 70 , 150 , 1 , 128 , 211 , 190 , 100])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn swap_enabled_set (& self) -> self :: event_builders :: SwapEnabledSetBuilder { self :: event_builders :: SwapEnabledSetBuilder (self . instance . event (self :: ethcontract :: H256 ([90 , 158 , 132 , 247 , 143 , 121 , 87 , 203 , 78 , 215 , 71 , 142 , 176 , 252 , 173 , 53 , 238 , 78 , 203 , 226 , 224 , 242 , 152 , 66 , 11 , 40 , 163 , 149 , 83 , 146 , 87 , 63])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn swap_fee_percentage_changed (& self) -> self :: event_builders :: SwapFeePercentageChangedBuilder { self :: event_builders :: SwapFeePercentageChangedBuilder (self . instance . event (self :: ethcontract :: H256 ([169 , 186 , 63 , 254 , 11 , 108 , 54 , 107 , 129 , 35 , 44 , 170 , 179 , 134 , 5 , 160 , 105 , 154 , 213 , 57 , 141 , 108 , 206 , 118 , 249 , 30 , 232 , 9 , 227 , 34 , 218 , 252])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn transfer (& self) -> self :: event_builders :: TransferBuilder { self :: event_builders :: TransferBuilder (self . instance . event (self :: ethcontract :: H256 ([221 , 242 , 82 , 173 , 27 , 226 , 200 , 155 , 105 , 194 , 176 , 104 , 252 , 55 , 141 , 170 , 149 , 43 , 167 , 241 , 99 , 196 , 161 , 22 , 40 , 245 , 90 , 77 , 245 , 35 , 179 , 239])) . expect ("generated event filter") ,) } } # [doc = r" Module containing the generated event stream builders with type safe"] # [doc = r" filter methods for this contract's events."] pub mod event_builders { use super :: ethcontract ; use super :: event_data ; # [doc = "A builder for creating a filtered stream of `Approval` events."] pub struct ApprovalBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: Approval > ,) ; impl ApprovalBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = "Adds a filter for the owner event parameter."] pub fn owner (mut self , topic : self :: ethcontract :: Topic < self :: ethcontract :: Address >) -> Self { self . 0 = (self . 0) . topic0 (topic) ; self } # [doc = "Adds a filter for the spender event parameter."] pub fn spender (mut self , topic : self :: ethcontract :: Topic < self :: ethcontract :: Address >) -> Self { self . 0 = (self . 0) . topic1 (topic) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: Approval >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: Approval > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `GradualWeightUpdateScheduled` events."] pub struct GradualWeightUpdateScheduledBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: GradualWeightUpdateScheduled > ,) ; impl GradualWeightUpdateScheduledBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: GradualWeightUpdateScheduled >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: GradualWeightUpdateScheduled > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `PausedStateChanged` events."] pub struct PausedStateChangedBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: PausedStateChanged > ,) ; impl PausedStateChangedBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: PausedStateChanged >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: PausedStateChanged > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `SwapEnabledSet` events."] pub struct SwapEnabledSetBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: SwapEnabledSet > ,) ; impl SwapEnabledSetBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: SwapEnabledSet >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: SwapEnabledSet > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `SwapFeePercentageChanged` events."] pub struct SwapFeePercentageChangedBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: SwapFeePercentageChanged > ,) ; impl SwapFeePercentageChangedBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: SwapFeePercentageChanged >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: SwapFeePercentageChanged > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `Transfer` events."] pub struct TransferBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: Transfer > ,) ; impl TransferBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = "Adds a filter for the from event parameter."] pub fn from (mut self , topic : self :: ethcontract :: Topic < self :: ethcontract :: Address >) -> Self { self . 0 = (self . 0) . topic0 (topic) ; self } # [doc = "Adds a filter for the to event parameter."] pub fn to (mut self , topic : self :: ethcontract :: Topic < self :: ethcontract :: Address >) -> Self { self . 0 = (self . 0) . topic1 (topic) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: Transfer >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: Transfer > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } } impl Contract { # [doc = r" Returns a log stream with all events."] pub fn all_events (& self) -> self :: ethcontract :: dyns :: DynAllEventsBuilder < Event > { self :: ethcontract :: dyns :: DynAllEventsBuilder :: new (self . raw_instance () . web3 () , self . address () , self . deployment_information () ,) } } # [doc = r" A contract event."] # [derive (Clone , Debug , Eq , PartialEq ,)] pub enum Event { Approval (self :: event_data :: Approval) , GradualWeightUpdateScheduled (self :: event_data :: GradualWeightUpdateScheduled) , PausedStateChanged (self :: event_data :: PausedStateChanged) , SwapEnabledSet (self :: event_data :: SwapEnabledSet) , SwapFeePercentageChanged (self :: event_data :: SwapFeePercentageChanged) , Transfer (self :: event_data :: Transfer) , } impl self :: ethcontract :: contract :: ParseLog for Event { fn parse_log (log : self :: ethcontract :: RawLog ,) -> Result < Self , self :: ethcontract :: errors :: ExecutionError > { let standard_event = log . topics . get (0) . copied () . map (| topic | match topic { self :: ethcontract :: H256 ([140 , 91 , 225 , 229 , 235 , 236 , 125 , 91 , 209 , 79 , 113 , 66 , 125 , 30 , 132 , 243 , 221 , 3 , 20 , 192 , 247 , 178 , 41 , 30 , 91 , 32 , 10 , 200 , 199 , 195 , 185 , 37]) => Ok (Event :: Approval (log . clone () . decode (Contract :: raw_contract () . abi . event ("Approval") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([15 , 54 , 49 , 249 , 218 , 176 , 129 , 105 , 209 , 219 , 33 , 198 , 220 , 95 , 50 , 83 , 111 , 178 , 176 , 166 , 185 , 187 , 83 , 48 , 215 , 28 , 82 , 19 , 47 , 150 , 139 , 224]) => Ok (Event :: GradualWeightUpdateScheduled (log . clone () . decode (Contract :: raw_contract () . abi . event ("GradualWeightUpdateScheduled") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([158 , 58 , 94 , 55 , 34 , 69 , 50 , 222 , 166 , 123 , 137 , 250 , 206 , 24 , 87 , 3 , 115 , 138 , 34 , 138 , 110 , 138 , 35 , 222 , 229 , 70 , 150 , 1 , 128 , 211 , 190 , 100]) => Ok (Event :: PausedStateChanged (log . clone () . decode (Contract :: raw_contract () . abi . event ("PausedStateChanged") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([90 , 158 , 132 , 247 , 143 , 121 , 87 , 203 , 78 , 215 , 71 , 142 , 176 , 252 , 173 , 53 , 238 , 78 , 203 , 226 , 224 , 242 , 152 , 66 , 11 , 40 , 163 , 149 , 83 , 146 , 87 , 63]) => Ok (Event :: SwapEnabledSet (log . clone () . decode (Contract :: raw_contract () . abi . event ("SwapEnabledSet") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([169 , 186 , 63 , 254 , 11 , 108 , 54 , 107 , 129 , 35 , 44 , 170 , 179 , 134 , 5 , 160 , 105 , 154 , 213 , 57 , 141 , 108 , 206 , 118 , 249 , 30 , 232 , 9 , 227 , 34 , 218 , 252]) => Ok (Event :: SwapFeePercentageChanged (log . clone () . decode (Contract :: raw_contract () . abi . event ("SwapFeePercentageChanged") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([221 , 242 , 82 , 173 , 27 , 226 , 200 , 155 , 105 , 194 , 176 , 104 , 252 , 55 , 141 , 170 , 149 , 43 , 167 , 241 , 99 , 196 , 161 , 22 , 40 , 245 , 90 , 77 , 245 , 35 , 179 , 239]) => Ok (Event :: Transfer (log . clone () . decode (Contract :: raw_contract () . abi . event ("Transfer") . expect ("generated event decode")) ?)) , _ => Err (self :: ethcontract :: errors :: ExecutionError :: from (self :: ethcontract :: common :: abi :: Error :: InvalidData)) , }) ; if let Some (Ok (data)) = standard_event { return Ok (data) ; } Err (self :: ethcontract :: errors :: ExecutionError :: from (self :: ethcontract :: common :: abi :: Error :: InvalidData)) } } } pub use self :: liquidity_bootstrapping_pool :: Contract as LiquidityBootstrappingPool ;