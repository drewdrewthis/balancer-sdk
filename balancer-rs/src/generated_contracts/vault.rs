# [allow (dead_code)] pub mod vault { # [rustfmt :: skip] use ethcontract as ethcontract ; # [doc = "Generated by `ethcontract`"] # [derive (Clone)] pub struct Contract { methods : Methods , } impl Contract { # [doc = r" Retrieves the raw contract instance used to generate the type safe"] # [doc = r" API for this contract."] pub fn raw_contract () -> & 'static self :: ethcontract :: Contract { use self :: ethcontract :: common :: artifact :: truffle :: TruffleLoader ; use self :: ethcontract :: private :: lazy_static ; use self :: ethcontract :: Contract ; lazy_static ! { pub static ref CONTRACT : Contract = { # [allow (unused_mut)] let mut contract = TruffleLoader :: new () . load_contract_from_str ("{\"contractName\":\"Vault\",\"abi\":[{\"type\":\"constructor\",\"inputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"authorizer\",\"type\":\"address\"},{\"internalType\":\"contract IWETH\",\"name\":\"weth\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pauseWindowDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferPeriodDuration\",\"type\":\"uint256\"}]},{\"type\":\"function\",\"name\":\"WETH\",\"inputs\":[],\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"batchSwap\",\"inputs\":[{\"internalType\":\"enum IVault.SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"struct IVault.BatchSwapStep[]\",\"name\":\"swaps\",\"type\":\"tuple[]\",\"components\":[{\"type\":\"bytes32\"},{\"type\":\"uint256\"},{\"type\":\"uint256\"},{\"type\":\"uint256\"},{\"type\":\"bytes\"}]},{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\",\"components\":[{\"type\":\"address\"},{\"type\":\"bool\"},{\"type\":\"address\"},{\"type\":\"bool\"}]},{\"internalType\":\"int256[]\",\"name\":\"limits\",\"type\":\"int256[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"assetDeltas\",\"type\":\"int256[]\"}],\"constant\":false,\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"deregisterTokens\",\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"exitPool\",\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"struct IVault.ExitPoolRequest\",\"name\":\"request\",\"type\":\"tuple\",\"components\":[{\"type\":\"address[]\"},{\"type\":\"uint256[]\"},{\"type\":\"bytes\"},{\"type\":\"bool\"}]}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"flashLoan\",\"inputs\":[{\"internalType\":\"contract IFlashLoanRecipient\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"getActionId\",\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getAuthorizer\",\"inputs\":[],\"outputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"\",\"type\":\"address\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getDomainSeparator\",\"inputs\":[],\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getInternalBalance\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getNextNonce\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getPausedState\",\"inputs\":[],\"outputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pauseWindowEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bufferPeriodEndTime\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getPool\",\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"enum IVault.PoolSpecialization\",\"name\":\"\",\"type\":\"uint8\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getPoolTokenInfo\",\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"managed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastChangeBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetManager\",\"type\":\"address\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getPoolTokens\",\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastChangeBlock\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getProtocolFeesCollector\",\"inputs\":[],\"outputs\":[{\"internalType\":\"contract ProtocolFeesCollector\",\"name\":\"\",\"type\":\"address\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"hasApprovedRelayer\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"joinPool\",\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"struct IVault.JoinPoolRequest\",\"name\":\"request\",\"type\":\"tuple\",\"components\":[{\"type\":\"address[]\"},{\"type\":\"uint256[]\"},{\"type\":\"bytes\"},{\"type\":\"bool\"}]}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"managePoolBalance\",\"inputs\":[{\"internalType\":\"struct IVault.PoolBalanceOp[]\",\"name\":\"ops\",\"type\":\"tuple[]\",\"components\":[{\"type\":\"uint8\"},{\"type\":\"bytes32\"},{\"type\":\"address\"},{\"type\":\"uint256\"}]}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"manageUserBalance\",\"inputs\":[{\"internalType\":\"struct IVault.UserBalanceOp[]\",\"name\":\"ops\",\"type\":\"tuple[]\",\"components\":[{\"type\":\"uint8\"},{\"type\":\"address\"},{\"type\":\"uint256\"},{\"type\":\"address\"},{\"type\":\"address\"}]}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"queryBatchSwap\",\"inputs\":[{\"internalType\":\"enum IVault.SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"struct IVault.BatchSwapStep[]\",\"name\":\"swaps\",\"type\":\"tuple[]\",\"components\":[{\"type\":\"bytes32\"},{\"type\":\"uint256\"},{\"type\":\"uint256\"},{\"type\":\"uint256\"},{\"type\":\"bytes\"}]},{\"internalType\":\"contract IAsset[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\",\"components\":[{\"type\":\"address\"},{\"type\":\"bool\"},{\"type\":\"address\"},{\"type\":\"bool\"}]}],\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"registerPool\",\"inputs\":[{\"internalType\":\"enum IVault.PoolSpecialization\",\"name\":\"specialization\",\"type\":\"uint8\"}],\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"registerTokens\",\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"assetManagers\",\"type\":\"address[]\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setAuthorizer\",\"inputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"newAuthorizer\",\"type\":\"address\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setPaused\",\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setRelayerApproval\",\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"swap\",\"inputs\":[{\"internalType\":\"struct IVault.SingleSwap\",\"name\":\"singleSwap\",\"type\":\"tuple\",\"components\":[{\"type\":\"bytes32\"},{\"type\":\"uint8\"},{\"type\":\"address\"},{\"type\":\"address\"},{\"type\":\"uint256\"},{\"type\":\"bytes\"}]},{\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\",\"components\":[{\"type\":\"address\"},{\"type\":\"bool\"},{\"type\":\"address\"},{\"type\":\"bool\"}]},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCalculated\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"payable\"},{\"type\":\"event\",\"name\":\"AuthorizerChanged\",\"inputs\":[{\"name\":\"newAuthorizer\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"ExternalBalanceTransfer\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"sender\",\"type\":\"address\",\"indexed\":false},{\"name\":\"recipient\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"FlashLoan\",\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\",\"indexed\":false},{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"feeAmount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"InternalBalanceChanged\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\",\"indexed\":false},{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"delta\",\"type\":\"int256\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"PausedStateChanged\",\"inputs\":[{\"name\":\"paused\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"PoolBalanceChanged\",\"inputs\":[{\"name\":\"poolId\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"liquidityProvider\",\"type\":\"address\",\"indexed\":false},{\"name\":\"tokens\",\"type\":\"address[]\",\"indexed\":false},{\"name\":\"deltas\",\"type\":\"int256[]\",\"indexed\":false},{\"name\":\"protocolFeeAmounts\",\"type\":\"uint256[]\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"PoolBalanceManaged\",\"inputs\":[{\"name\":\"poolId\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"assetManager\",\"type\":\"address\",\"indexed\":false},{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"cashDelta\",\"type\":\"int256\",\"indexed\":false},{\"name\":\"managedDelta\",\"type\":\"int256\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"PoolRegistered\",\"inputs\":[{\"name\":\"poolId\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"poolAddress\",\"type\":\"address\",\"indexed\":false},{\"name\":\"specialization\",\"type\":\"uint8\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"RelayerApprovalChanged\",\"inputs\":[{\"name\":\"relayer\",\"type\":\"address\",\"indexed\":false},{\"name\":\"sender\",\"type\":\"address\",\"indexed\":false},{\"name\":\"approved\",\"type\":\"bool\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Swap\",\"inputs\":[{\"name\":\"poolId\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"tokenIn\",\"type\":\"address\",\"indexed\":false},{\"name\":\"tokenOut\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amountIn\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amountOut\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"TokensDeregistered\",\"inputs\":[{\"name\":\"poolId\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"tokens\",\"type\":\"address[]\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"TokensRegistered\",\"inputs\":[{\"name\":\"poolId\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"tokens\",\"type\":\"address[]\",\"indexed\":false},{\"name\":\"assetManagers\",\"type\":\"address[]\",\"indexed\":false}],\"anonymous\":false}],\"bytecode\":\"\",\"networks\":{},\"devdoc\":{\"details\":null,\"methods\":{}},\"userdoc\":{\"details\":null,\"methods\":{}}}") . expect ("valid contract JSON") ; contract } ; } & CONTRACT } # [doc = r" Creates a new contract instance with the specified `web3`"] # [doc = r" provider at the given `Address`."] # [doc = r""] # [doc = r" Note that this does not verify that a contract with a matching"] # [doc = r" `Abi` is actually deployed at the given address."] pub fn at < F , B , T > (web3 : & self :: ethcontract :: web3 :: api :: Web3 < T > , address : self :: ethcontract :: Address ,) -> Self where F : std :: future :: Future < Output = Result < self :: ethcontract :: json :: Value , self :: ethcontract :: web3 :: Error , > , > + Send + 'static , B : std :: future :: Future < Output = Result < Vec < Result < self :: ethcontract :: json :: Value , self :: ethcontract :: web3 :: Error , > , > , self :: ethcontract :: web3 :: Error , > , > + Send + 'static , T : self :: ethcontract :: web3 :: Transport < Out = F > + self :: ethcontract :: web3 :: BatchTransport < Batch = B > + Send + Sync + 'static , { Contract :: with_deployment_info (web3 , address , None) } # [doc = r" Creates a new contract instance with the specified `web3` provider with"] # [doc = r" the given `Abi` at the given `Address` and an optional transaction hash."] # [doc = r" This hash is used to retrieve contract related information such as the"] # [doc = r" creation block (which is useful for fetching all historic events)."] # [doc = r""] # [doc = r" Note that this does not verify that a contract with a matching `Abi` is"] # [doc = r" actually deployed at the given address nor that the transaction hash,"] # [doc = r" when provided, is actually for this contract deployment."] pub fn with_deployment_info < F , B , T > (web3 : & self :: ethcontract :: web3 :: api :: Web3 < T > , address : self :: ethcontract :: Address , deployment_information : Option < ethcontract :: common :: DeploymentInformation > ,) -> Self where F : std :: future :: Future < Output = Result < self :: ethcontract :: json :: Value , self :: ethcontract :: web3 :: Error , > , > + Send + 'static , B : std :: future :: Future < Output = Result < Vec < Result < self :: ethcontract :: json :: Value , self :: ethcontract :: web3 :: Error , > , > , self :: ethcontract :: web3 :: Error , > , > + Send + 'static , T : self :: ethcontract :: web3 :: Transport < Out = F > + self :: ethcontract :: web3 :: BatchTransport < Batch = B > + Send + Sync + 'static , { use self :: ethcontract :: Instance ; use self :: ethcontract :: transport :: DynTransport ; use self :: ethcontract :: web3 :: api :: Web3 ; let transport = DynTransport :: new (web3 . transport () . clone ()) ; let web3 = Web3 :: new (transport) ; let abi = Self :: raw_contract () . abi . clone () ; let instance = Instance :: with_deployment_info (web3 , abi , address , deployment_information) ; Contract :: from_raw (instance) } # [doc = r" Creates a contract from a raw instance."] fn from_raw (instance : self :: ethcontract :: dyns :: DynInstance) -> Self { let methods = Methods { instance } ; Contract { methods } } # [doc = r" Returns the contract address being used by this instance."] pub fn address (& self) -> self :: ethcontract :: Address { self . raw_instance () . address () } # [doc = r" Returns the deployment information of the contract"] # [doc = r" if it is known, `None` otherwise."] pub fn deployment_information (& self) -> Option < ethcontract :: common :: DeploymentInformation > { self . raw_instance () . deployment_information () } # [doc = r" Returns a reference to the default method options used by this"] # [doc = r" contract."] pub fn defaults (& self) -> & self :: ethcontract :: contract :: MethodDefaults { & self . raw_instance () . defaults } # [doc = r" Returns a mutable reference to the default method options used"] # [doc = r" by this contract."] pub fn defaults_mut (& mut self) -> & mut self :: ethcontract :: contract :: MethodDefaults { & mut self . raw_instance_mut () . defaults } # [doc = r" Returns a reference to the raw runtime instance used by this"] # [doc = r" contract."] pub fn raw_instance (& self) -> & self :: ethcontract :: dyns :: DynInstance { & self . methods . instance } # [doc = r" Returns a mutable reference to the raw runtime instance used by"] # [doc = r" this contract."] fn raw_instance_mut (& mut self) -> & mut self :: ethcontract :: dyns :: DynInstance { & mut self . methods . instance } } impl std :: fmt :: Debug for Contract { fn fmt (& self , f : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { f . debug_tuple (stringify ! (Vault)) . field (& self . address ()) . finish () } } impl Contract { # [doc = r" Returns an object that allows accessing typed method signatures."] pub fn signatures () -> Signatures { Signatures } # [doc = r" Retrieves a reference to type containing all the generated"] # [doc = r" contract methods. This can be used for methods where the name"] # [doc = r" would collide with a common method (like `at` or `deployed`)."] pub fn methods (& self) -> & Methods { & self . methods } } # [doc = r" Type containing signatures for all methods for generated contract type."] # [derive (Clone , Copy)] pub struct Signatures ; impl Signatures { # [doc = "Returns signature for method `WETH():(address)`."] # [allow (clippy :: type_complexity)] pub fn weth (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: Address > { self :: ethcontract :: contract :: Signature :: new ([173 , 92 , 70 , 72]) } # [doc = "Returns signature for method `batchSwap(uint8,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,address,bool),int256[],uint256):(int256[])`."] # [allow (clippy :: type_complexity)] pub fn batch_swap (& self) -> self :: ethcontract :: contract :: Signature < (u8 , Vec < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) > , Vec < self :: ethcontract :: Address > , (self :: ethcontract :: Address , bool , self :: ethcontract :: Address , bool ,) , Vec < self :: ethcontract :: I256 > , self :: ethcontract :: U256 ,) , Vec < self :: ethcontract :: I256 > > { self :: ethcontract :: contract :: Signature :: new ([148 , 91 , 206 , 201]) } # [doc = "Returns signature for method `deregisterTokens(bytes32,address[])`."] # [allow (clippy :: type_complexity)] pub fn deregister_tokens (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , Vec < self :: ethcontract :: Address > ,) , () > { self :: ethcontract :: contract :: Signature :: new ([125 , 58 , 235 , 150]) } # [doc = "Returns signature for method `exitPool(bytes32,address,address,(address[],uint256[],bytes,bool))`."] # [allow (clippy :: type_complexity)] pub fn exit_pool (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: Address , self :: ethcontract :: Address , (Vec < self :: ethcontract :: Address > , Vec < self :: ethcontract :: U256 > , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> , bool ,) ,) , () > { self :: ethcontract :: contract :: Signature :: new ([139 , 219 , 57 , 19]) } # [doc = "Returns signature for method `flashLoan(address,address[],uint256[],bytes)`."] # [allow (clippy :: type_complexity)] pub fn flash_loan (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address , Vec < self :: ethcontract :: Address > , Vec < self :: ethcontract :: U256 > , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) , () > { self :: ethcontract :: contract :: Signature :: new ([92 , 56 , 68 , 158]) } # [doc = "Returns signature for method `getActionId(bytes4):(bytes32)`."] # [allow (clippy :: type_complexity)] pub fn get_action_id (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 4] > ,) , self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > > { self :: ethcontract :: contract :: Signature :: new ([133 , 28 , 27 , 179]) } # [doc = "Returns signature for method `getAuthorizer():(address)`."] # [allow (clippy :: type_complexity)] pub fn get_authorizer (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: Address > { self :: ethcontract :: contract :: Signature :: new ([170 , 171 , 173 , 197]) } # [doc = "Returns signature for method `getDomainSeparator():(bytes32)`."] # [allow (clippy :: type_complexity)] pub fn get_domain_separator (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > > { self :: ethcontract :: contract :: Signature :: new ([237 , 36 , 145 , 29]) } # [doc = "Returns signature for method `getInternalBalance(address,address[]):(uint256[])`."] # [allow (clippy :: type_complexity)] pub fn get_internal_balance (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address , Vec < self :: ethcontract :: Address > ,) , Vec < self :: ethcontract :: U256 > > { self :: ethcontract :: contract :: Signature :: new ([15 , 90 , 110 , 250]) } # [doc = "Returns signature for method `getNextNonce(address):(uint256)`."] # [allow (clippy :: type_complexity)] pub fn get_next_nonce (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address ,) , self :: ethcontract :: U256 > { self :: ethcontract :: contract :: Signature :: new ([144 , 25 , 59 , 124]) } # [doc = "Returns signature for method `getPausedState():(bool,uint256,uint256)`."] # [allow (clippy :: type_complexity)] pub fn get_paused_state (& self) -> self :: ethcontract :: contract :: Signature < () , (bool , self :: ethcontract :: U256 , self :: ethcontract :: U256) > { self :: ethcontract :: contract :: Signature :: new ([28 , 13 , 224 , 81]) } # [doc = "Returns signature for method `getPool(bytes32):(address,uint8)`."] # [allow (clippy :: type_complexity)] pub fn get_pool (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > ,) , (self :: ethcontract :: Address , u8) > { self :: ethcontract :: contract :: Signature :: new ([246 , 192 , 9 , 39]) } # [doc = "Returns signature for method `getPoolTokenInfo(bytes32,address):(uint256,uint256,uint256,address)`."] # [allow (clippy :: type_complexity)] pub fn get_pool_token_info (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: Address ,) , (self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: Address) > { self :: ethcontract :: contract :: Signature :: new ([176 , 95 , 142 , 72]) } # [doc = "Returns signature for method `getPoolTokens(bytes32):(address[],uint256[],uint256)`."] # [allow (clippy :: type_complexity)] pub fn get_pool_tokens (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > ,) , (Vec < self :: ethcontract :: Address > , Vec < self :: ethcontract :: U256 > , self :: ethcontract :: U256) > { self :: ethcontract :: contract :: Signature :: new ([249 , 77 , 70 , 104]) } # [doc = "Returns signature for method `getProtocolFeesCollector():(address)`."] # [allow (clippy :: type_complexity)] pub fn get_protocol_fees_collector (& self) -> self :: ethcontract :: contract :: Signature < () , self :: ethcontract :: Address > { self :: ethcontract :: contract :: Signature :: new ([210 , 148 , 108 , 43]) } # [doc = "Returns signature for method `hasApprovedRelayer(address,address):(bool)`."] # [allow (clippy :: type_complexity)] pub fn has_approved_relayer (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address , self :: ethcontract :: Address ,) , bool > { self :: ethcontract :: contract :: Signature :: new ([254 , 201 , 13 , 114]) } # [doc = "Returns signature for method `joinPool(bytes32,address,address,(address[],uint256[],bytes,bool))`."] # [allow (clippy :: type_complexity)] pub fn join_pool (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: Address , self :: ethcontract :: Address , (Vec < self :: ethcontract :: Address > , Vec < self :: ethcontract :: U256 > , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> , bool ,) ,) , () > { self :: ethcontract :: contract :: Signature :: new ([185 , 92 , 172 , 40]) } # [doc = "Returns signature for method `managePoolBalance((uint8,bytes32,address,uint256)[])`."] # [allow (clippy :: type_complexity)] pub fn manage_pool_balance (& self) -> self :: ethcontract :: contract :: Signature < (Vec < (u8 , self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: Address , self :: ethcontract :: U256 ,) > ,) , () > { self :: ethcontract :: contract :: Signature :: new ([230 , 196 , 96 , 146]) } # [doc = "Returns signature for method `manageUserBalance((uint8,address,uint256,address,address)[])`."] # [allow (clippy :: type_complexity)] pub fn manage_user_balance (& self) -> self :: ethcontract :: contract :: Signature < (Vec < (u8 , self :: ethcontract :: Address , self :: ethcontract :: U256 , self :: ethcontract :: Address , self :: ethcontract :: Address ,) > ,) , () > { self :: ethcontract :: contract :: Signature :: new ([14 , 142 , 62 , 132]) } # [doc = "Returns signature for method `queryBatchSwap(uint8,(bytes32,uint256,uint256,uint256,bytes)[],address[],(address,bool,address,bool)):(int256[])`."] # [allow (clippy :: type_complexity)] pub fn query_batch_swap (& self) -> self :: ethcontract :: contract :: Signature < (u8 , Vec < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) > , Vec < self :: ethcontract :: Address > , (self :: ethcontract :: Address , bool , self :: ethcontract :: Address , bool ,) ,) , Vec < self :: ethcontract :: I256 > > { self :: ethcontract :: contract :: Signature :: new ([248 , 77 , 6 , 110]) } # [doc = "Returns signature for method `registerPool(uint8):(bytes32)`."] # [allow (clippy :: type_complexity)] pub fn register_pool (& self) -> self :: ethcontract :: contract :: Signature < (u8 ,) , self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > > { self :: ethcontract :: contract :: Signature :: new ([9 , 178 , 118 , 15]) } # [doc = "Returns signature for method `registerTokens(bytes32,address[],address[])`."] # [allow (clippy :: type_complexity)] pub fn register_tokens (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , Vec < self :: ethcontract :: Address > , Vec < self :: ethcontract :: Address > ,) , () > { self :: ethcontract :: contract :: Signature :: new ([102 , 169 , 199 , 210]) } # [doc = "Returns signature for method `setAuthorizer(address)`."] # [allow (clippy :: type_complexity)] pub fn set_authorizer (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address ,) , () > { self :: ethcontract :: contract :: Signature :: new ([5 , 138 , 98 , 143]) } # [doc = "Returns signature for method `setPaused(bool)`."] # [allow (clippy :: type_complexity)] pub fn set_paused (& self) -> self :: ethcontract :: contract :: Signature < (bool ,) , () > { self :: ethcontract :: contract :: Signature :: new ([22 , 195 , 139 , 60]) } # [doc = "Returns signature for method `setRelayerApproval(address,address,bool)`."] # [allow (clippy :: type_complexity)] pub fn set_relayer_approval (& self) -> self :: ethcontract :: contract :: Signature < (self :: ethcontract :: Address , self :: ethcontract :: Address , bool ,) , () > { self :: ethcontract :: contract :: Signature :: new ([250 , 110 , 103 , 29]) } # [doc = "Returns signature for method `swap((bytes32,uint8,address,address,uint256,bytes),(address,bool,address,bool),uint256,uint256):(uint256)`."] # [allow (clippy :: type_complexity)] pub fn swap (& self) -> self :: ethcontract :: contract :: Signature < ((self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , u8 , self :: ethcontract :: Address , self :: ethcontract :: Address , self :: ethcontract :: U256 , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) , (self :: ethcontract :: Address , bool , self :: ethcontract :: Address , bool ,) , self :: ethcontract :: U256 , self :: ethcontract :: U256 ,) , self :: ethcontract :: U256 > { self :: ethcontract :: contract :: Signature :: new ([82 , 187 , 190 , 41]) } } # [doc = r" Type containing all contract methods for generated contract type."] # [derive (Clone)] pub struct Methods { instance : self :: ethcontract :: dyns :: DynInstance , } # [allow (clippy :: too_many_arguments , clippy :: type_complexity)] impl Methods { # [doc = "Generated by `ethcontract`"] pub fn weth (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: Address > { self . instance . view_method ([173 , 92 , 70 , 72] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn batch_swap (& self , kind : u8 , swaps : Vec < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) > , assets : Vec < self :: ethcontract :: Address > , funds : (self :: ethcontract :: Address , bool , self :: ethcontract :: Address , bool ,) , limits : Vec < self :: ethcontract :: I256 > , deadline : self :: ethcontract :: U256) -> self :: ethcontract :: dyns :: DynMethodBuilder < Vec < self :: ethcontract :: I256 > > { self . instance . method ([148 , 91 , 206 , 201] , (kind , swaps , assets , funds , limits , deadline ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn deregister_tokens (& self , pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , tokens : Vec < self :: ethcontract :: Address >) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([125 , 58 , 235 , 150] , (pool_id , tokens ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn exit_pool (& self , pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , sender : self :: ethcontract :: Address , recipient : self :: ethcontract :: Address , request : (Vec < self :: ethcontract :: Address > , Vec < self :: ethcontract :: U256 > , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> , bool ,)) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([139 , 219 , 57 , 19] , (pool_id , sender , recipient , request ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn flash_loan (& self , recipient : self :: ethcontract :: Address , tokens : Vec < self :: ethcontract :: Address > , amounts : Vec < self :: ethcontract :: U256 > , user_data : self :: ethcontract :: tokens :: Bytes < Vec < u8 >>) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([92 , 56 , 68 , 158] , (recipient , tokens , amounts , user_data ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_action_id (& self , selector : self :: ethcontract :: tokens :: Bytes < [u8 ; 4] >) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > > { self . instance . view_method ([133 , 28 , 27 , 179] , (selector ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_authorizer (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: Address > { self . instance . view_method ([170 , 171 , 173 , 197] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_domain_separator (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > > { self . instance . view_method ([237 , 36 , 145 , 29] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_internal_balance (& self , user : self :: ethcontract :: Address , tokens : Vec < self :: ethcontract :: Address >) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < Vec < self :: ethcontract :: U256 > > { self . instance . view_method ([15 , 90 , 110 , 250] , (user , tokens ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_next_nonce (& self , user : self :: ethcontract :: Address) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: U256 > { self . instance . view_method ([144 , 25 , 59 , 124] , (user ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_paused_state (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < (bool , self :: ethcontract :: U256 , self :: ethcontract :: U256) > { self . instance . view_method ([28 , 13 , 224 , 81] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_pool (& self , pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] >) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < (self :: ethcontract :: Address , u8) > { self . instance . view_method ([246 , 192 , 9 , 39] , (pool_id ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_pool_token_info (& self , pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , token : self :: ethcontract :: Address) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < (self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: Address) > { self . instance . view_method ([176 , 95 , 142 , 72] , (pool_id , token ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_pool_tokens (& self , pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] >) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < (Vec < self :: ethcontract :: Address > , Vec < self :: ethcontract :: U256 > , self :: ethcontract :: U256) > { self . instance . view_method ([249 , 77 , 70 , 104] , (pool_id ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn get_protocol_fees_collector (& self) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < self :: ethcontract :: Address > { self . instance . view_method ([210 , 148 , 108 , 43] , ()) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn has_approved_relayer (& self , user : self :: ethcontract :: Address , relayer : self :: ethcontract :: Address) -> self :: ethcontract :: dyns :: DynViewMethodBuilder < bool > { self . instance . view_method ([254 , 201 , 13 , 114] , (user , relayer ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn join_pool (& self , pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , sender : self :: ethcontract :: Address , recipient : self :: ethcontract :: Address , request : (Vec < self :: ethcontract :: Address > , Vec < self :: ethcontract :: U256 > , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> , bool ,)) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([185 , 92 , 172 , 40] , (pool_id , sender , recipient , request ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn manage_pool_balance (& self , ops : Vec < (u8 , self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: Address , self :: ethcontract :: U256 ,) >) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([230 , 196 , 96 , 146] , (ops ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn manage_user_balance (& self , ops : Vec < (u8 , self :: ethcontract :: Address , self :: ethcontract :: U256 , self :: ethcontract :: Address , self :: ethcontract :: Address ,) >) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([14 , 142 , 62 , 132] , (ops ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn query_batch_swap (& self , kind : u8 , swaps : Vec < (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: U256 , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) > , assets : Vec < self :: ethcontract :: Address > , funds : (self :: ethcontract :: Address , bool , self :: ethcontract :: Address , bool ,)) -> self :: ethcontract :: dyns :: DynMethodBuilder < Vec < self :: ethcontract :: I256 > > { self . instance . method ([248 , 77 , 6 , 110] , (kind , swaps , assets , funds ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn register_pool (& self , specialization : u8) -> self :: ethcontract :: dyns :: DynMethodBuilder < self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > > { self . instance . method ([9 , 178 , 118 , 15] , (specialization ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn register_tokens (& self , pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , tokens : Vec < self :: ethcontract :: Address > , asset_managers : Vec < self :: ethcontract :: Address >) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([102 , 169 , 199 , 210] , (pool_id , tokens , asset_managers ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn set_authorizer (& self , new_authorizer : self :: ethcontract :: Address) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([5 , 138 , 98 , 143] , (new_authorizer ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn set_paused (& self , paused : bool) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([22 , 195 , 139 , 60] , (paused ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn set_relayer_approval (& self , sender : self :: ethcontract :: Address , relayer : self :: ethcontract :: Address , approved : bool) -> self :: ethcontract :: dyns :: DynMethodBuilder < () > { self . instance . method ([250 , 110 , 103 , 29] , (sender , relayer , approved ,)) . expect ("generated call") } # [doc = "Generated by `ethcontract`"] pub fn swap (& self , single_swap : (self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , u8 , self :: ethcontract :: Address , self :: ethcontract :: Address , self :: ethcontract :: U256 , self :: ethcontract :: tokens :: Bytes < Vec < u8 >> ,) , funds : (self :: ethcontract :: Address , bool , self :: ethcontract :: Address , bool ,) , limit : self :: ethcontract :: U256 , deadline : self :: ethcontract :: U256) -> self :: ethcontract :: dyns :: DynMethodBuilder < self :: ethcontract :: U256 > { self . instance . method ([82 , 187 , 190 , 41] , (single_swap , funds , limit , deadline ,)) . expect ("generated call") } } impl std :: ops :: Deref for Contract { type Target = Methods ; fn deref (& self) -> & Self :: Target { & self . methods } } # [doc = r" Module containing all generated data models for this contract's"] # [doc = r" events."] pub mod event_data { use super :: ethcontract ; # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct AuthorizerChanged { pub new_authorizer : self :: ethcontract :: Address , } impl AuthorizerChanged { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([148 , 185 , 121 , 182 , 131 , 26 , 81 , 41 , 62 , 38 , 65 , 66 , 111 , 151 , 116 , 127 , 238 , 212 , 111 , 23 , 119 , 159 , 237 , 156 , 209 , 141 , 30 , 206 , 252 , 254 , 146 , 239]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`AuthorizerChanged(address)`"] pub fn abi_signature () -> & 'static str { "AuthorizerChanged(address)" } } impl self :: ethcontract :: tokens :: Tokenize for AuthorizerChanged { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (new_authorizer ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (AuthorizerChanged { new_authorizer }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct ExternalBalanceTransfer { pub token : self :: ethcontract :: Address , pub sender : self :: ethcontract :: Address , pub recipient : self :: ethcontract :: Address , pub amount : self :: ethcontract :: U256 , } impl ExternalBalanceTransfer { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([84 , 10 , 26 , 63 , 40 , 52 , 12 , 174 , 195 , 54 , 200 , 29 , 141 , 123 , 61 , 241 , 57 , 238 , 92 , 220 , 24 , 57 , 164 , 242 , 131 , 215 , 235 , 183 , 234 , 174 , 45 , 92]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`ExternalBalanceTransfer(address,address,address,uint256)`"] pub fn abi_signature () -> & 'static str { "ExternalBalanceTransfer(address,address,address,uint256)" } } impl self :: ethcontract :: tokens :: Tokenize for ExternalBalanceTransfer { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (token , sender , recipient , amount ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (ExternalBalanceTransfer { token , sender , recipient , amount }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct FlashLoan { pub recipient : self :: ethcontract :: Address , pub token : self :: ethcontract :: Address , pub amount : self :: ethcontract :: U256 , pub fee_amount : self :: ethcontract :: U256 , } impl FlashLoan { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([13 , 125 , 117 , 224 , 26 , 185 , 87 , 128 , 211 , 205 , 28 , 142 , 192 , 221 , 108 , 44 , 225 , 158 , 58 , 32 , 66 , 126 , 236 , 139 , 245 , 50 , 131 , 182 , 251 , 142 , 149 , 240]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`FlashLoan(address,address,uint256,uint256)`"] pub fn abi_signature () -> & 'static str { "FlashLoan(address,address,uint256,uint256)" } } impl self :: ethcontract :: tokens :: Tokenize for FlashLoan { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (recipient , token , amount , fee_amount ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (FlashLoan { recipient , token , amount , fee_amount }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct InternalBalanceChanged { pub user : self :: ethcontract :: Address , pub token : self :: ethcontract :: Address , pub delta : self :: ethcontract :: I256 , } impl InternalBalanceChanged { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([24 , 225 , 234 , 65 , 57 , 230 , 132 , 19 , 215 , 208 , 138 , 167 , 82 , 231 , 21 , 104 , 227 , 107 , 44 , 91 , 249 , 64 , 137 , 51 , 20 , 194 , 197 , 176 , 30 , 170 , 12 , 66]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`InternalBalanceChanged(address,address,int256)`"] pub fn abi_signature () -> & 'static str { "InternalBalanceChanged(address,address,int256)" } } impl self :: ethcontract :: tokens :: Tokenize for InternalBalanceChanged { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (user , token , delta ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (InternalBalanceChanged { user , token , delta }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct PausedStateChanged { pub paused : bool , } impl PausedStateChanged { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([158 , 58 , 94 , 55 , 34 , 69 , 50 , 222 , 166 , 123 , 137 , 250 , 206 , 24 , 87 , 3 , 115 , 138 , 34 , 138 , 110 , 138 , 35 , 222 , 229 , 70 , 150 , 1 , 128 , 211 , 190 , 100]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`PausedStateChanged(bool)`"] pub fn abi_signature () -> & 'static str { "PausedStateChanged(bool)" } } impl self :: ethcontract :: tokens :: Tokenize for PausedStateChanged { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (paused ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (PausedStateChanged { paused }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct PoolBalanceChanged { pub pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , pub liquidity_provider : self :: ethcontract :: Address , pub tokens : Vec < self :: ethcontract :: Address > , pub deltas : Vec < self :: ethcontract :: I256 > , pub protocol_fee_amounts : Vec < self :: ethcontract :: U256 > , } impl PoolBalanceChanged { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([229 , 206 , 36 , 144 , 135 , 206 , 4 , 240 , 90 , 149 , 113 , 146 , 67 , 84 , 0 , 253 , 151 , 134 , 141 , 186 , 14 , 106 , 75 , 76 , 4 , 154 , 191 , 138 , 248 , 13 , 174 , 120]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`PoolBalanceChanged(bytes32,address,address[],int256[],uint256[])`"] pub fn abi_signature () -> & 'static str { "PoolBalanceChanged(bytes32,address,address[],int256[],uint256[])" } } impl self :: ethcontract :: tokens :: Tokenize for PoolBalanceChanged { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (pool_id , liquidity_provider , tokens , deltas , protocol_fee_amounts ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (PoolBalanceChanged { pool_id , liquidity_provider , tokens , deltas , protocol_fee_amounts }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct PoolBalanceManaged { pub pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , pub asset_manager : self :: ethcontract :: Address , pub token : self :: ethcontract :: Address , pub cash_delta : self :: ethcontract :: I256 , pub managed_delta : self :: ethcontract :: I256 , } impl PoolBalanceManaged { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([110 , 220 , 175 , 98 , 65 , 16 , 91 , 76 , 148 , 194 , 239 , 219 , 243 , 166 , 177 , 36 , 88 , 235 , 61 , 7 , 190 , 58 , 14 , 129 , 210 , 75 , 19 , 196 , 64 , 69 , 254 , 122]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`PoolBalanceManaged(bytes32,address,address,int256,int256)`"] pub fn abi_signature () -> & 'static str { "PoolBalanceManaged(bytes32,address,address,int256,int256)" } } impl self :: ethcontract :: tokens :: Tokenize for PoolBalanceManaged { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (pool_id , asset_manager , token , cash_delta , managed_delta ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (PoolBalanceManaged { pool_id , asset_manager , token , cash_delta , managed_delta }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct PoolRegistered { pub pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , pub pool_address : self :: ethcontract :: Address , pub specialization : u8 , } impl PoolRegistered { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([60 , 19 , 188 , 48 , 184 , 232 , 120 , 197 , 63 , 210 , 163 , 107 , 103 , 148 , 9 , 192 , 115 , 175 , 215 , 89 , 80 , 190 , 67 , 216 , 133 , 135 , 104 , 233 , 86 , 251 , 194 , 14]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`PoolRegistered(bytes32,address,uint8)`"] pub fn abi_signature () -> & 'static str { "PoolRegistered(bytes32,address,uint8)" } } impl self :: ethcontract :: tokens :: Tokenize for PoolRegistered { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (pool_id , pool_address , specialization ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (PoolRegistered { pool_id , pool_address , specialization }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct RelayerApprovalChanged { pub relayer : self :: ethcontract :: Address , pub sender : self :: ethcontract :: Address , pub approved : bool , } impl RelayerApprovalChanged { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([70 , 150 , 31 , 219 , 69 , 2 , 182 , 70 , 213 , 9 , 95 , 186 , 118 , 0 , 72 , 106 , 138 , 192 , 80 , 65 , 213 , 92 , 223 , 15 , 22 , 237 , 103 , 113 , 128 , 181 , 202 , 216]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`RelayerApprovalChanged(address,address,bool)`"] pub fn abi_signature () -> & 'static str { "RelayerApprovalChanged(address,address,bool)" } } impl self :: ethcontract :: tokens :: Tokenize for RelayerApprovalChanged { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (relayer , sender , approved ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (RelayerApprovalChanged { relayer , sender , approved }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct Swap { pub pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , pub token_in : self :: ethcontract :: Address , pub token_out : self :: ethcontract :: Address , pub amount_in : self :: ethcontract :: U256 , pub amount_out : self :: ethcontract :: U256 , } impl Swap { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([33 , 112 , 199 , 65 , 196 , 21 , 49 , 174 , 194 , 14 , 124 , 16 , 124 , 36 , 238 , 207 , 221 , 21 , 230 , 156 , 155 , 176 , 168 , 221 , 55 , 177 , 132 , 11 , 158 , 11 , 32 , 123]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`Swap(bytes32,address,address,uint256,uint256)`"] pub fn abi_signature () -> & 'static str { "Swap(bytes32,address,address,uint256,uint256)" } } impl self :: ethcontract :: tokens :: Tokenize for Swap { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (pool_id , token_in , token_out , amount_in , amount_out ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (Swap { pool_id , token_in , token_out , amount_in , amount_out }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct TokensDeregistered { pub pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , pub tokens : Vec < self :: ethcontract :: Address > , } impl TokensDeregistered { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([125 , 205 , 198 , 208 , 46 , 244 , 12 , 124 , 26 , 112 , 70 , 160 , 17 , 176 , 88 , 189 , 127 , 152 , 143 , 161 , 78 , 32 , 166 , 99 , 68 , 249 , 212 , 230 , 6 , 87 , 214 , 16]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`TokensDeregistered(bytes32,address[])`"] pub fn abi_signature () -> & 'static str { "TokensDeregistered(bytes32,address[])" } } impl self :: ethcontract :: tokens :: Tokenize for TokensDeregistered { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (pool_id , tokens ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (TokensDeregistered { pool_id , tokens }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } # [derive (Clone , Debug , Default , Eq , PartialEq ,)] pub struct TokensRegistered { pub pool_id : self :: ethcontract :: tokens :: Bytes < [u8 ; 32] > , pub tokens : Vec < self :: ethcontract :: Address > , pub asset_managers : Vec < self :: ethcontract :: Address > , } impl TokensRegistered { # [doc = r" Retrieves the signature for the event this data corresponds to."] # [doc = r" This signature is the Keccak-256 hash of the ABI signature of"] # [doc = r" this event."] pub fn signature () -> self :: ethcontract :: H256 { self :: ethcontract :: H256 ([245 , 132 , 125 , 63 , 33 , 151 , 177 , 108 , 220 , 210 , 9 , 142 , 201 , 93 , 9 , 5 , 205 , 26 , 189 , 175 , 65 , 95 , 7 , 187 , 124 , 239 , 43 , 186 , 138 , 197 , 222 , 196]) } # [doc = r" Retrieves the ABI signature for the event this data corresponds"] # [doc = r" to. For this event the value should always be:"] # [doc = r""] # [doc = "`TokensRegistered(bytes32,address[],address[])`"] pub fn abi_signature () -> & 'static str { "TokensRegistered(bytes32,address[],address[])" } } impl self :: ethcontract :: tokens :: Tokenize for TokensRegistered { fn from_token (token : self :: ethcontract :: common :: abi :: Token ,) -> Result < Self , self :: ethcontract :: tokens :: Error > { let (pool_id , tokens , asset_managers ,) = self :: ethcontract :: tokens :: Tokenize :: from_token (token) ? ; Ok (TokensRegistered { pool_id , tokens , asset_managers }) } fn into_token (self) -> self :: ethcontract :: common :: abi :: Token { unimplemented ! ("events are only decoded, not encoded") } } } impl Contract { # [doc = r" Retrieves a handle to a type containing for creating event"] # [doc = r" streams for all the contract events."] pub fn events (& self) -> Events < '_ > { Events { instance : self . raw_instance () , } } } pub struct Events < 'a > { instance : & 'a self :: ethcontract :: dyns :: DynInstance , } impl Events < '_ > { # [doc = r" Generated by `ethcontract`."] pub fn authorizer_changed (& self) -> self :: event_builders :: AuthorizerChangedBuilder { self :: event_builders :: AuthorizerChangedBuilder (self . instance . event (self :: ethcontract :: H256 ([148 , 185 , 121 , 182 , 131 , 26 , 81 , 41 , 62 , 38 , 65 , 66 , 111 , 151 , 116 , 127 , 238 , 212 , 111 , 23 , 119 , 159 , 237 , 156 , 209 , 141 , 30 , 206 , 252 , 254 , 146 , 239])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn external_balance_transfer (& self) -> self :: event_builders :: ExternalBalanceTransferBuilder { self :: event_builders :: ExternalBalanceTransferBuilder (self . instance . event (self :: ethcontract :: H256 ([84 , 10 , 26 , 63 , 40 , 52 , 12 , 174 , 195 , 54 , 200 , 29 , 141 , 123 , 61 , 241 , 57 , 238 , 92 , 220 , 24 , 57 , 164 , 242 , 131 , 215 , 235 , 183 , 234 , 174 , 45 , 92])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn flash_loan (& self) -> self :: event_builders :: FlashLoanBuilder { self :: event_builders :: FlashLoanBuilder (self . instance . event (self :: ethcontract :: H256 ([13 , 125 , 117 , 224 , 26 , 185 , 87 , 128 , 211 , 205 , 28 , 142 , 192 , 221 , 108 , 44 , 225 , 158 , 58 , 32 , 66 , 126 , 236 , 139 , 245 , 50 , 131 , 182 , 251 , 142 , 149 , 240])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn internal_balance_changed (& self) -> self :: event_builders :: InternalBalanceChangedBuilder { self :: event_builders :: InternalBalanceChangedBuilder (self . instance . event (self :: ethcontract :: H256 ([24 , 225 , 234 , 65 , 57 , 230 , 132 , 19 , 215 , 208 , 138 , 167 , 82 , 231 , 21 , 104 , 227 , 107 , 44 , 91 , 249 , 64 , 137 , 51 , 20 , 194 , 197 , 176 , 30 , 170 , 12 , 66])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn paused_state_changed (& self) -> self :: event_builders :: PausedStateChangedBuilder { self :: event_builders :: PausedStateChangedBuilder (self . instance . event (self :: ethcontract :: H256 ([158 , 58 , 94 , 55 , 34 , 69 , 50 , 222 , 166 , 123 , 137 , 250 , 206 , 24 , 87 , 3 , 115 , 138 , 34 , 138 , 110 , 138 , 35 , 222 , 229 , 70 , 150 , 1 , 128 , 211 , 190 , 100])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn pool_balance_changed (& self) -> self :: event_builders :: PoolBalanceChangedBuilder { self :: event_builders :: PoolBalanceChangedBuilder (self . instance . event (self :: ethcontract :: H256 ([229 , 206 , 36 , 144 , 135 , 206 , 4 , 240 , 90 , 149 , 113 , 146 , 67 , 84 , 0 , 253 , 151 , 134 , 141 , 186 , 14 , 106 , 75 , 76 , 4 , 154 , 191 , 138 , 248 , 13 , 174 , 120])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn pool_balance_managed (& self) -> self :: event_builders :: PoolBalanceManagedBuilder { self :: event_builders :: PoolBalanceManagedBuilder (self . instance . event (self :: ethcontract :: H256 ([110 , 220 , 175 , 98 , 65 , 16 , 91 , 76 , 148 , 194 , 239 , 219 , 243 , 166 , 177 , 36 , 88 , 235 , 61 , 7 , 190 , 58 , 14 , 129 , 210 , 75 , 19 , 196 , 64 , 69 , 254 , 122])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn pool_registered (& self) -> self :: event_builders :: PoolRegisteredBuilder { self :: event_builders :: PoolRegisteredBuilder (self . instance . event (self :: ethcontract :: H256 ([60 , 19 , 188 , 48 , 184 , 232 , 120 , 197 , 63 , 210 , 163 , 107 , 103 , 148 , 9 , 192 , 115 , 175 , 215 , 89 , 80 , 190 , 67 , 216 , 133 , 135 , 104 , 233 , 86 , 251 , 194 , 14])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn relayer_approval_changed (& self) -> self :: event_builders :: RelayerApprovalChangedBuilder { self :: event_builders :: RelayerApprovalChangedBuilder (self . instance . event (self :: ethcontract :: H256 ([70 , 150 , 31 , 219 , 69 , 2 , 182 , 70 , 213 , 9 , 95 , 186 , 118 , 0 , 72 , 106 , 138 , 192 , 80 , 65 , 213 , 92 , 223 , 15 , 22 , 237 , 103 , 113 , 128 , 181 , 202 , 216])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn swap (& self) -> self :: event_builders :: SwapBuilder { self :: event_builders :: SwapBuilder (self . instance . event (self :: ethcontract :: H256 ([33 , 112 , 199 , 65 , 196 , 21 , 49 , 174 , 194 , 14 , 124 , 16 , 124 , 36 , 238 , 207 , 221 , 21 , 230 , 156 , 155 , 176 , 168 , 221 , 55 , 177 , 132 , 11 , 158 , 11 , 32 , 123])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn tokens_deregistered (& self) -> self :: event_builders :: TokensDeregisteredBuilder { self :: event_builders :: TokensDeregisteredBuilder (self . instance . event (self :: ethcontract :: H256 ([125 , 205 , 198 , 208 , 46 , 244 , 12 , 124 , 26 , 112 , 70 , 160 , 17 , 176 , 88 , 189 , 127 , 152 , 143 , 161 , 78 , 32 , 166 , 99 , 68 , 249 , 212 , 230 , 6 , 87 , 214 , 16])) . expect ("generated event filter") ,) } # [doc = r" Generated by `ethcontract`."] pub fn tokens_registered (& self) -> self :: event_builders :: TokensRegisteredBuilder { self :: event_builders :: TokensRegisteredBuilder (self . instance . event (self :: ethcontract :: H256 ([245 , 132 , 125 , 63 , 33 , 151 , 177 , 108 , 220 , 210 , 9 , 142 , 201 , 93 , 9 , 5 , 205 , 26 , 189 , 175 , 65 , 95 , 7 , 187 , 124 , 239 , 43 , 186 , 138 , 197 , 222 , 196])) . expect ("generated event filter") ,) } } # [doc = r" Module containing the generated event stream builders with type safe"] # [doc = r" filter methods for this contract's events."] pub mod event_builders { use super :: ethcontract ; use super :: event_data ; # [doc = "A builder for creating a filtered stream of `AuthorizerChanged` events."] pub struct AuthorizerChangedBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: AuthorizerChanged > ,) ; impl AuthorizerChangedBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: AuthorizerChanged >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: AuthorizerChanged > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `ExternalBalanceTransfer` events."] pub struct ExternalBalanceTransferBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: ExternalBalanceTransfer > ,) ; impl ExternalBalanceTransferBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: ExternalBalanceTransfer >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: ExternalBalanceTransfer > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `FlashLoan` events."] pub struct FlashLoanBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: FlashLoan > ,) ; impl FlashLoanBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: FlashLoan >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: FlashLoan > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `InternalBalanceChanged` events."] pub struct InternalBalanceChangedBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: InternalBalanceChanged > ,) ; impl InternalBalanceChangedBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: InternalBalanceChanged >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: InternalBalanceChanged > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `PausedStateChanged` events."] pub struct PausedStateChangedBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: PausedStateChanged > ,) ; impl PausedStateChangedBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: PausedStateChanged >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: PausedStateChanged > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `PoolBalanceChanged` events."] pub struct PoolBalanceChangedBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: PoolBalanceChanged > ,) ; impl PoolBalanceChangedBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: PoolBalanceChanged >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: PoolBalanceChanged > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `PoolBalanceManaged` events."] pub struct PoolBalanceManagedBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: PoolBalanceManaged > ,) ; impl PoolBalanceManagedBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: PoolBalanceManaged >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: PoolBalanceManaged > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `PoolRegistered` events."] pub struct PoolRegisteredBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: PoolRegistered > ,) ; impl PoolRegisteredBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: PoolRegistered >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: PoolRegistered > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `RelayerApprovalChanged` events."] pub struct RelayerApprovalChangedBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: RelayerApprovalChanged > ,) ; impl RelayerApprovalChangedBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: RelayerApprovalChanged >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: RelayerApprovalChanged > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `Swap` events."] pub struct SwapBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: Swap > ,) ; impl SwapBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: Swap >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: Swap > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `TokensDeregistered` events."] pub struct TokensDeregisteredBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: TokensDeregistered > ,) ; impl TokensDeregisteredBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: TokensDeregistered >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: TokensDeregistered > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } # [doc = "A builder for creating a filtered stream of `TokensRegistered` events."] pub struct TokensRegisteredBuilder (# [doc = r" The inner event builder."] pub self :: ethcontract :: dyns :: DynEventBuilder < self :: event_data :: TokensRegistered > ,) ; impl TokensRegisteredBuilder { # [doc = r" Sets the starting block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the latest block."] # [allow (clippy :: wrong_self_convention)] pub fn from_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . from_block (block) ; self } # [doc = r" Sets the last block from which to stream logs for."] # [doc = r""] # [doc = r" If left unset defaults to the streaming until the end of days."] # [allow (clippy :: wrong_self_convention)] pub fn to_block (mut self , block : self :: ethcontract :: BlockNumber) -> Self { self . 0 = (self . 0) . to_block (block) ; self } # [doc = r" Limits the number of events that can be retrieved by this filter."] # [doc = r""] # [doc = r" Note that this parameter is non-standard."] pub fn limit (mut self , value : usize) -> Self { self . 0 = (self . 0) . limit (value) ; self } # [doc = r" Sets the polling interval. This is used as the interval between"] # [doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."] pub fn poll_interval (mut self , value : std :: time :: Duration) -> Self { self . 0 = (self . 0) . poll_interval (value) ; self } # [doc = r" Returns a future that resolves with a collection of all existing"] # [doc = r" logs matching the builder parameters."] pub async fn query (self) -> std :: result :: Result < std :: vec :: Vec < self :: ethcontract :: Event < self :: event_data :: TokensRegistered >> , self :: ethcontract :: errors :: EventError , > { (self . 0) . query () . await } # [doc = r" Creates an event stream from the current event builder."] pub fn stream (self) -> impl self :: ethcontract :: futures :: stream :: Stream < Item = std :: result :: Result < self :: ethcontract :: StreamEvent < self :: event_data :: TokensRegistered > , self :: ethcontract :: errors :: EventError , > , > { (self . 0) . stream () } } } impl Contract { # [doc = r" Returns a log stream with all events."] pub fn all_events (& self) -> self :: ethcontract :: dyns :: DynAllEventsBuilder < Event > { self :: ethcontract :: dyns :: DynAllEventsBuilder :: new (self . raw_instance () . web3 () , self . address () , self . deployment_information () ,) } } # [doc = r" A contract event."] # [derive (Clone , Debug , Eq , PartialEq ,)] pub enum Event { AuthorizerChanged (self :: event_data :: AuthorizerChanged) , ExternalBalanceTransfer (self :: event_data :: ExternalBalanceTransfer) , FlashLoan (self :: event_data :: FlashLoan) , InternalBalanceChanged (self :: event_data :: InternalBalanceChanged) , PausedStateChanged (self :: event_data :: PausedStateChanged) , PoolBalanceChanged (self :: event_data :: PoolBalanceChanged) , PoolBalanceManaged (self :: event_data :: PoolBalanceManaged) , PoolRegistered (self :: event_data :: PoolRegistered) , RelayerApprovalChanged (self :: event_data :: RelayerApprovalChanged) , Swap (self :: event_data :: Swap) , TokensDeregistered (self :: event_data :: TokensDeregistered) , TokensRegistered (self :: event_data :: TokensRegistered) , } impl self :: ethcontract :: contract :: ParseLog for Event { fn parse_log (log : self :: ethcontract :: RawLog ,) -> Result < Self , self :: ethcontract :: errors :: ExecutionError > { let standard_event = log . topics . get (0) . copied () . map (| topic | match topic { self :: ethcontract :: H256 ([148 , 185 , 121 , 182 , 131 , 26 , 81 , 41 , 62 , 38 , 65 , 66 , 111 , 151 , 116 , 127 , 238 , 212 , 111 , 23 , 119 , 159 , 237 , 156 , 209 , 141 , 30 , 206 , 252 , 254 , 146 , 239]) => Ok (Event :: AuthorizerChanged (log . clone () . decode (Contract :: raw_contract () . abi . event ("AuthorizerChanged") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([84 , 10 , 26 , 63 , 40 , 52 , 12 , 174 , 195 , 54 , 200 , 29 , 141 , 123 , 61 , 241 , 57 , 238 , 92 , 220 , 24 , 57 , 164 , 242 , 131 , 215 , 235 , 183 , 234 , 174 , 45 , 92]) => Ok (Event :: ExternalBalanceTransfer (log . clone () . decode (Contract :: raw_contract () . abi . event ("ExternalBalanceTransfer") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([13 , 125 , 117 , 224 , 26 , 185 , 87 , 128 , 211 , 205 , 28 , 142 , 192 , 221 , 108 , 44 , 225 , 158 , 58 , 32 , 66 , 126 , 236 , 139 , 245 , 50 , 131 , 182 , 251 , 142 , 149 , 240]) => Ok (Event :: FlashLoan (log . clone () . decode (Contract :: raw_contract () . abi . event ("FlashLoan") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([24 , 225 , 234 , 65 , 57 , 230 , 132 , 19 , 215 , 208 , 138 , 167 , 82 , 231 , 21 , 104 , 227 , 107 , 44 , 91 , 249 , 64 , 137 , 51 , 20 , 194 , 197 , 176 , 30 , 170 , 12 , 66]) => Ok (Event :: InternalBalanceChanged (log . clone () . decode (Contract :: raw_contract () . abi . event ("InternalBalanceChanged") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([158 , 58 , 94 , 55 , 34 , 69 , 50 , 222 , 166 , 123 , 137 , 250 , 206 , 24 , 87 , 3 , 115 , 138 , 34 , 138 , 110 , 138 , 35 , 222 , 229 , 70 , 150 , 1 , 128 , 211 , 190 , 100]) => Ok (Event :: PausedStateChanged (log . clone () . decode (Contract :: raw_contract () . abi . event ("PausedStateChanged") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([229 , 206 , 36 , 144 , 135 , 206 , 4 , 240 , 90 , 149 , 113 , 146 , 67 , 84 , 0 , 253 , 151 , 134 , 141 , 186 , 14 , 106 , 75 , 76 , 4 , 154 , 191 , 138 , 248 , 13 , 174 , 120]) => Ok (Event :: PoolBalanceChanged (log . clone () . decode (Contract :: raw_contract () . abi . event ("PoolBalanceChanged") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([110 , 220 , 175 , 98 , 65 , 16 , 91 , 76 , 148 , 194 , 239 , 219 , 243 , 166 , 177 , 36 , 88 , 235 , 61 , 7 , 190 , 58 , 14 , 129 , 210 , 75 , 19 , 196 , 64 , 69 , 254 , 122]) => Ok (Event :: PoolBalanceManaged (log . clone () . decode (Contract :: raw_contract () . abi . event ("PoolBalanceManaged") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([60 , 19 , 188 , 48 , 184 , 232 , 120 , 197 , 63 , 210 , 163 , 107 , 103 , 148 , 9 , 192 , 115 , 175 , 215 , 89 , 80 , 190 , 67 , 216 , 133 , 135 , 104 , 233 , 86 , 251 , 194 , 14]) => Ok (Event :: PoolRegistered (log . clone () . decode (Contract :: raw_contract () . abi . event ("PoolRegistered") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([70 , 150 , 31 , 219 , 69 , 2 , 182 , 70 , 213 , 9 , 95 , 186 , 118 , 0 , 72 , 106 , 138 , 192 , 80 , 65 , 213 , 92 , 223 , 15 , 22 , 237 , 103 , 113 , 128 , 181 , 202 , 216]) => Ok (Event :: RelayerApprovalChanged (log . clone () . decode (Contract :: raw_contract () . abi . event ("RelayerApprovalChanged") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([33 , 112 , 199 , 65 , 196 , 21 , 49 , 174 , 194 , 14 , 124 , 16 , 124 , 36 , 238 , 207 , 221 , 21 , 230 , 156 , 155 , 176 , 168 , 221 , 55 , 177 , 132 , 11 , 158 , 11 , 32 , 123]) => Ok (Event :: Swap (log . clone () . decode (Contract :: raw_contract () . abi . event ("Swap") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([125 , 205 , 198 , 208 , 46 , 244 , 12 , 124 , 26 , 112 , 70 , 160 , 17 , 176 , 88 , 189 , 127 , 152 , 143 , 161 , 78 , 32 , 166 , 99 , 68 , 249 , 212 , 230 , 6 , 87 , 214 , 16]) => Ok (Event :: TokensDeregistered (log . clone () . decode (Contract :: raw_contract () . abi . event ("TokensDeregistered") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([245 , 132 , 125 , 63 , 33 , 151 , 177 , 108 , 220 , 210 , 9 , 142 , 201 , 93 , 9 , 5 , 205 , 26 , 189 , 175 , 65 , 95 , 7 , 187 , 124 , 239 , 43 , 186 , 138 , 197 , 222 , 196]) => Ok (Event :: TokensRegistered (log . clone () . decode (Contract :: raw_contract () . abi . event ("TokensRegistered") . expect ("generated event decode")) ?)) , _ => Err (self :: ethcontract :: errors :: ExecutionError :: from (self :: ethcontract :: common :: abi :: Error :: InvalidData)) , }) ; if let Some (Ok (data)) = standard_event { return Ok (data) ; } Err (self :: ethcontract :: errors :: ExecutionError :: from (self :: ethcontract :: common :: abi :: Error :: InvalidData)) } } } pub use self :: vault :: Contract as Vault ;